<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WebFuse</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://webfuse.cn/"/>
  <updated>2019-01-20T08:54:33.485Z</updated>
  <id>http://webfuse.cn/</id>
  
  <author>
    <name>Hing Kwan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebMvcConfigurationSupport和WebMvcConfigurer</title>
    <link href="http://webfuse.cn/2019/01/20/WebMvcConfigurationSupport%E5%92%8CWebMvcConfigurer/"/>
    <id>http://webfuse.cn/2019/01/20/WebMvcConfigurationSupport和WebMvcConfigurer/</id>
    <published>2019-01-20T07:41:33.000Z</published>
    <updated>2019-01-20T08:54:33.485Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot帮我们做了很多的事情，但是有的时候会有自定义的Handler，Interceptor，ViewResolver，MessageConverter等，该怎么配置呢？为什么继承了WebMvcConfigurationSupport后有些配置会不生效呢？WebMvcConfigurer又是什么呢？</p>
<h2 id="WebMvcConfigurationSupport"><a href="#WebMvcConfigurationSupport" class="headerlink" title="WebMvcConfigurationSupport"></a>WebMvcConfigurationSupport</h2><p>我们继承WebMvcConfigurationSupport可以自定义SpringMvc的配置。</p>
<p>跟踪发现DelegatingWebMvcConfiguration类是WebMvcConfigurationSupport的一个实现类，DelegatingWebMvcConfiguration类的setConfigurers方法可以收集所有的WebMvcConfigurer实现类中的配置组合起来，组成一个超级配置（这些配置会覆盖掉默认的配置）。而@EnableWebMvc又引入了DelegatingWebMvcConfiguration。</p>
<p>所以，我们继承了WebMvcConfigurationSupport，而后使用@EnableWebMvc会覆盖掉原来的配置。</p>
<h2 id="WebMvcConfigurer"><a href="#WebMvcConfigurer" class="headerlink" title="WebMvcConfigurer"></a>WebMvcConfigurer</h2><p>WebMvcConfigurer配置类其实是Spring内部的一种配置方式，采用JavaBean的形式来代替传统的xml配置文件形式进行针对框架个性化定制。</p>
<p>在官方文档中有这么一段话：</p>
<p>&gt;</p>
<blockquote>
<p>If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc.</p>
</blockquote>
<p>所以，如果我们想要在Auto-configuration的基础上配置自定义的interceptors, formatters, view controllers等功能话，我们可以实现WebMvcConfigurer，并用@Configuration注释。</p>
<p>WebMvcConfigurer的主要方法有：</p>
<ul>
<li>configurePathMatch：配置路由请求规则</li>
<li>configureContentNegotiation：内容协商配置</li>
<li>configureAsyncSupport</li>
<li>configureDefaultServletHandling：默认静态资源处理器</li>
<li>addFormatters：注册自定义转化器</li>
<li>addInterceptors：拦截器配置</li>
<li>addResourceHandlers：资源处理</li>
<li>addCorsMappings：CORS配置</li>
<li>addViewControllers：视图跳转控制器</li>
<li>configureViewResolvers：配置视图解析</li>
<li>addArgumentResolvers：添加自定义方法参数处理器</li>
<li>addReturnValueHandlers：添加自定义返回结果处理器</li>
<li>configureMessageConverters：配置消息转换器。重载会覆盖默认注册的HttpMessageConverter</li>
<li>extendMessageConverters：配置消息转换器。仅添加一个自定义的HttpMessageConverter.</li>
<li>configureHandlerExceptionResolvers：配置异常转换器</li>
<li>extendHandlerExceptionResolvers：添加异常转化器</li>
<li>getValidator</li>
<li>getMessageCodesResolver</li>
</ul>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ul>
<li>使用@EnableWebMvc注解 等于 扩展了WebMvcConfigurationSupport，但是没有重写任何方法</li>
<li>使用“extends WebMvcConfigurationSupport”方式（需要添加@EnableWebMvc），会屏蔽掉springBoot的@EnableAutoConfiguration中的设置</li>
<li>使用“implement WebMvcConfigurer”可以配置自定义的配置，同时也使用了@EnableAutoConfiguration中的设置</li>
<li>使用“implement WebMvcConfigurer + @EnableWebMvc”，会屏蔽掉springBoot的@EnableAutoConfiguration中的设置</li>
</ul>
<blockquote>
<p>这里的“@EnableAutoConfiguration中的设置”是指，读取 application.properties 或 application.yml 文件中的配置。</p>
</blockquote>
<p>所以，如果需要使用springBoot的@EnableAutoConfiguration中的设置，那么就只需要“implement WebMvcConfigurer”即可。如果，需要自己扩展同时不使用@EnableAutoConfiguration中的设置，可以选择另外的方式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot帮我们做了很多的事情，但是有的时候会有自定义的Handler，Interceptor，ViewResolver，MessageConverter等，该怎么配置呢？为什么继承了WebMvcConfigurationSupport后有些配置会不生效呢？Web
    
    </summary>
    
      <category term="Spring" scheme="http://webfuse.cn/categories/Spring/"/>
    
    
      <category term="实战" scheme="http://webfuse.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="Spring" scheme="http://webfuse.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>基于Docker搭建以太坊私有网络</title>
    <link href="http://webfuse.cn/2018/12/18/%E5%9F%BA%E4%BA%8EDocker%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E6%9C%89%E7%BD%91%E7%BB%9C/"/>
    <id>http://webfuse.cn/2018/12/18/基于Docker搭建以太坊私有网络/</id>
    <published>2018-12-18T09:37:38.000Z</published>
    <updated>2018-12-18T09:40:57.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Running-in-Docker"><a href="#Running-in-Docker" class="headerlink" title="Running in Docker"></a>Running in Docker</h2><p>参考<a href="https://github.com/ethereum/go-ethereum/wiki/Running-in-Docker" target="_blank" rel="external">官方的Running in Docker</a>，具体的解释如下：</p>
<h3 id="运行节点"><a href="#运行节点" class="headerlink" title="运行节点"></a>运行节点</h3><p>拉取镜像：</p>
<p><code>docker pull ethereum/client-go</code></p>
<p>启动一个节点：</p>
<p><code>docker run -it -p 30303:30303 ethereum/client-go</code></p>
<p>启动一个节点并在8545上运行JSON-RPC接口：</p>
<p><code>docker run -it -p 8545:8545 -p 30303:30303 ethereum/client-go --rpc --rpcaddr &quot;0.0.0.0&quot;</code></p>
<p>注意：“0.0.0.0”参数会在8545接口上接收所有主机发送的请求，公共网络慎用！</p>
<p>使用javascript控制台进行交互操作，可运行下命令启动节点：</p>
<p><code>docker run -it -p 30303:30303 ethereum/client-go console</code></p>
<h3 id="指定区块链数据存储位置"><a href="#指定区块链数据存储位置" class="headerlink" title="指定区块链数据存储位置"></a>指定区块链数据存储位置</h3><p><code>docker run -it -p 30303:30303 -v /path/on/host:/root/.ethereum ethereum/client-go</code></p>
<p>-v参数指定了存储的路径。上面的命令会将/root/.ethereum挂载到本地路径/path/on/host下面。这样，容器启动以后，数据的实际存储路径就在/path/on/host下。</p>
<h3 id="使用启动的节点"><a href="#使用启动的节点" class="headerlink" title="使用启动的节点"></a>使用启动的节点</h3><p>运行上面的命令后，节点会自动去拉取主网的区块数据。我们可以连接到运行的容器中去执行各个操作。</p>
<p>运行<code>docker ps -a</code>查看容器实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">~ docker ps -a</div><div class="line">CONTAINER ID        IMAGE                COMMAND             CREATED             STATUS                     PORTS               NAMES</div><div class="line">3791b8c1df57        ethereum/client-go   &quot;geth&quot;              19 minutes ago      Exited (0) 6 minutes ago                       eloquent_wiles</div></pre></td></tr></table></figure>
<p>执行命令<code>docker exec -it eloquent_wiles /bin/sh</code>，其中eloquent_wiles是容器的名字。这样，它就连接到了现在运行的容器了。</p>
<p>示例操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/ # geth attach</div><div class="line">WARN [12-18|07:49:15.868] Sanitizing cache to Go&apos;s GC limits       provided=1024 updated=666</div><div class="line">Welcome to the Geth JavaScript console!</div><div class="line"></div><div class="line">instance: Geth/v1.8.19-unstable-9a000601/linux-amd64/go1.11.2</div><div class="line"> modules: admin:1.0 debug:1.0 eth:1.0 ethash:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0</div><div class="line"></div><div class="line">&gt; eth.syncing</div><div class="line">&#123;</div><div class="line">  currentBlock: 11504,</div><div class="line">  highestBlock: 6907887,</div><div class="line">  knownStates: 40307,</div><div class="line">  pulledStates: 17241,</div><div class="line">  startingBlock: 725</div><div class="line">&#125;</div><div class="line">&gt; eth.blockNumber</div><div class="line">0</div><div class="line">&gt; net.peerCount</div><div class="line">2</div><div class="line">&gt; eth.syncing</div><div class="line">&#123;</div><div class="line">  currentBlock: 27043,</div><div class="line">  highestBlock: 6907887,</div><div class="line">  knownStates: 61031,</div><div class="line">  pulledStates: 40281,</div><div class="line">  startingBlock: 725</div><div class="line">&#125;</div><div class="line">&gt; exit</div></pre></td></tr></table></figure>
<p>默认情况下，当节点启动时会在 datadir 指定的目录之下，生成一个名字为 geth.ipc 的文件，当程序关闭时此文件随之消失。可以使用–ipcpath参数修改掉路径。可以配合 attach 命令来进入与 geth 节点进行 js 交互的窗口。基本命令为：<code>/geth attach rpc:/path/on/host/geth.ipc</code></p>
<p>关于eth.blockNumber返回0的原因可以查看：</p>
<ul>
<li><a href="https://github.com/ethereum/go-ethereum/issues/14338" target="_blank" rel="external">eth.blockNumber is 0 while syncing #14338</a></li>
<li><a href="https://github.com/ethereum/go-ethereum/issues/16147" target="_blank" rel="external">eth.getBlock(“latest”).number is always 0 #16147</a></li>
</ul>
<h3 id="个性化Docker启动命令"><a href="#个性化Docker启动命令" class="headerlink" title="个性化Docker启动命令"></a>个性化Docker启动命令</h3><p>先来一条执行的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -it -d --name ethereum-node -p 8545:8545 -p 30303:30303 --network eth-network --ip 192.168.0.34 -v /path/on/host:/root/.ethereum ethereum/client-go --rinkeby --rpc --rpcaddr &quot;0.0.0.0&quot; --rpcapi &quot;admin,debug,eth,miner,net,personal,shh,txpool,web3,db&quot; --nodiscover --networkid 15 --fast --cache=512 --dev console 3&gt;&gt;eth.log&quot;</div></pre></td></tr></table></figure>
<h4 id="Docker参数"><a href="#Docker参数" class="headerlink" title="Docker参数"></a>Docker参数</h4><p>-it：交互式运行模式，-i 标准输入给容器，-t 分配一个虚拟终端</p>
<p>-d：以守护进程方式运行（后台）</p>
<p>-p：指定端口号</p>
<p>-P：随机分配端口号</p>
<p>–name：指定容器名称</p>
<p>–network：指定网络连接</p>
<p>–ip：分配ip地址</p>
<h4 id="Ethereum参数"><a href="#Ethereum参数" class="headerlink" title="Ethereum参数"></a>Ethereum参数</h4><p>–rinkeby：运行rinkeby网络，不设置默认为主网。</p>
<p>–rpc：启用HTTP-RPC服务</p>
<p>–rpcaddr：HTTP-RPC服务监听接口（默认：localhost）</p>
<p>–rpcapi：HTTP-RPC接口提供的api（默认：eth、net、web3）</p>
<p>–fast：快速同步模式启动Geth</p>
<p>–cache=512：内存容量分配</p>
<p>–dev：开发模式</p>
<p>–nodiscover：关闭节点自动发现，允许手动连接</p>
<p>–networkid：设置隔离网络（主网络id为1）</p>
<p>–verbosity 日志等级：0=silent, 1=error, 2=warn, 3=info, 4=debug, 5=detail (default: 3)</p>
<p>console：进入JavaScript控制台</p>
<p>更多的参数可以见下节。</p>
<h2 id="geth命令"><a href="#geth命令" class="headerlink" title="geth命令"></a>geth命令</h2><p>geth的命令可以在客户端运行<code>geth -help</code>或者在<a href="https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options" target="_blank" rel="external">Command Line Options</a>中查看。</p>
<p>中文资料可以参考：<a href="https://learnblockchain.cn/2017/11/29/geth_cmd_options/" target="_blank" rel="external">以太坊客户端Geth命令用法-参数详解</a></p>
<h2 id="实战经验"><a href="#实战经验" class="headerlink" title="实战经验"></a>实战经验</h2><ul>
<li>关于数据目录。启动时一定要指定一个足够大硬盘的路径，不建议使用默认路径，此路径在后面使用的过程中会频繁用到，如果私钥文件没有单独存储，那么也将存储在此目录下。</li>
<li>keystore 目录下的文件一定要慎重保管，一旦丢失将永远丢失对应地址上的资产，它们和创建账户时设置的密码一一匹配。</li>
<li>在真实生产环境中 rpcapi 的 personal、admin 等级别较高的操作权限慎重开启，一旦使用不当会导致系统安全问题。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Running-in-Docker&quot;&gt;&lt;a href=&quot;#Running-in-Docker&quot; class=&quot;headerlink&quot; title=&quot;Running in Docker&quot;&gt;&lt;/a&gt;Running in Docker&lt;/h2&gt;&lt;p&gt;参考&lt;a href=
    
    </summary>
    
      <category term="区块链" scheme="http://webfuse.cn/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="Docker" scheme="http://webfuse.cn/tags/Docker/"/>
    
      <category term="区块链" scheme="http://webfuse.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="http://webfuse.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>《精通比特币》第二版</title>
    <link href="http://webfuse.cn/2018/12/14/%E3%80%8A%E7%B2%BE%E9%80%9A%E6%AF%94%E7%89%B9%E5%B8%81%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%89%88/"/>
    <id>http://webfuse.cn/2018/12/14/《精通比特币》第二版/</id>
    <published>2018-12-14T06:33:06.000Z</published>
    <updated>2018-12-14T07:18:39.588Z</updated>
    
    <content type="html"><![CDATA[<p>为了方便查阅，将<a href="https://github.com/tianmingyun/MasterBitcoin2CN" target="_blank" rel="external">精通比特币</a>整理到这边。</p>
<p>目录如下：</p>
<ul>
<li><a href="/books/MasterBitcoin2CN/README.html">Introduction</a></li>
<li><a href="/books/MasterBitcoin2CN/cn-preface.html">中文版序言</a></li>
<li><a href="/books/MasterBitcoin2CN/trans-preface.html">译者序</a></li>
<li><a href="/books/MasterBitcoin2CN/preface.html">序言</a></li>
<li><a href="/books/MasterBitcoin2CN/second_edition_changes.html">第二版更新内容</a></li>
<li><a href="/books/MasterBitcoin2CN/glossary.html">词汇表</a></li>
<li><a href="/books/MasterBitcoin2CN/ch01.html">第一章介绍</a></li>
<li><a href="/books/MasterBitcoin2CN/ch02.html">第二章比特币原理</a></li>
<li><a href="/books/MasterBitcoin2CN/ch03.html">第三章比特币核心</a></li>
<li><a href="/books/MasterBitcoin2CN/ch04.html">第四章密钥和地址</a></li>
<li><a href="/books/MasterBitcoin2CN/ch05.html">第五章钱包</a></li>
<li><a href="/books/MasterBitcoin2CN/ch06.html">第六章交易</a></li>
<li><a href="/books/MasterBitcoin2CN/ch07.html">第七章高级交易和脚本</a></li>
<li><a href="/books/MasterBitcoin2CN/ch08.html">第八章比特币网络</a></li>
<li><a href="/books/MasterBitcoin2CN/ch09.html">第九章区块链</a></li>
<li><a href="/books/MasterBitcoin2CN/ch10.html">第十章挖矿和共识</a></li>
<li><a href="/books/MasterBitcoin2CN/ch11.html">第十一章比特币安全</a></li>
<li><a href="/books/MasterBitcoin2CN/ch12.html">第十二章比特币应用</a></li>
<li><a href="/books/MasterBitcoin2CN/appdx-bips.html">附录1：比特币改进提案（BIP）</a></li>
<li><a href="/books/MasterBitcoin2CN/appdx-bitcore.html">附录2：Bitcore</a></li>
<li><a href="/books/MasterBitcoin2CN/appdx-bx.html">附录3：Bitcoin Explorer（bx）命令</a></li>
<li><a href="/books/MasterBitcoin2CN/fappdx-pycoin.md">附录4：pycoin库、实用密钥程序ku和交易程序tx</a></li>
<li><a href="/books/MasterBitcoin2CN/appdx-scriptops.html">附录5 交易脚本的操作符、常量和符号</a></li>
<li><a href="/books/MasterBitcoin2CN/appdx-bitcoinwhitepaper.html">附录6 比特币白皮书</a></li>
<li><a href="/books/MasterBitcoin2CN/appdx-segwit.html">附录7 隔离见证</a></li>
<li><a href="/books/MasterBitcoin2CN/appdx-colored_coins.html">附录8 染色币</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了方便查阅，将&lt;a href=&quot;https://github.com/tianmingyun/MasterBitcoin2CN&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;精通比特币&lt;/a&gt;整理到这边。&lt;/p&gt;
&lt;p&gt;目录如下：&lt;/p&gt;
&lt;ul&gt;
&lt;l
    
    </summary>
    
      <category term="区块链" scheme="http://webfuse.cn/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://webfuse.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="BTC" scheme="http://webfuse.cn/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>Docker基本命令</title>
    <link href="http://webfuse.cn/2018/11/14/Docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://webfuse.cn/2018/11/14/Docker基本命令/</id>
    <published>2018-11-14T01:47:06.000Z</published>
    <updated>2018-11-14T01:48:41.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker基本命令"><a href="#Docker基本命令" class="headerlink" title="Docker基本命令"></a>Docker基本命令</h1><p>Docker命令分为两大类：客户端命令和服务端命令。前者主要是操作接口，后者用来启动Docker daemon。</p>
<p>客户端命令基本格式：<code>docker [OPTIONS] COMMAND [arg...]</code></p>
<p>服务端命令基本格式：<code>docker daemon  [OPTIONS]</code></p>
<h2 id="Docker客户端命令帮助"><a href="#Docker客户端命令帮助" class="headerlink" title="Docker客户端命令帮助"></a>Docker客户端命令帮助</h2><p>执行 <code>docker --help</code>命令可以列出Docker的使用帮助，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">Usage: docker [OPTIONS] COMMAND</div><div class="line"></div><div class="line">A self-sufficient runtime for containers</div><div class="line"></div><div class="line">Options:</div><div class="line">      --config string      设置docker客户端的配置文件地址</div><div class="line">  -D, --debug              开启调试模式，true|false</div><div class="line">  -H, --host list          需要连接的虚拟机的接口</div><div class="line">  -l, --log-level string   设置日志的等级</div><div class="line">      --tls                是否使用TLS协议（安全传输层协议），true | false</div><div class="line">      --tlscacert string   tls CA签名的可信证书文件路径 </div><div class="line">      --tlscert string     TLS可信证书文件路径 </div><div class="line">      --tlskey string      TLS秘钥文件路径 </div><div class="line">      --tlsverify          是否启用TLS校验 true|false</div><div class="line">  -v, --version            输出版本信息并退出</div><div class="line"></div><div class="line">管理命令:</div><div class="line">  checkpoint  管理检查点</div><div class="line">  config      管理集群中的配置信息</div><div class="line">  container   管理容器</div><div class="line">  image       管理镜像</div><div class="line">  network     管理容器的网络，包括查看、创建、删除、挂载、卸载等</div><div class="line">  node        管理Docker的集群结点，包括查看、更新、删除、提升/取消管理节点等</div><div class="line">  plugin      管理插件</div><div class="line">  secret      管理Docker敏感数据</div><div class="line">  service     管理Docker服务，包括创建、更新、删除等</div><div class="line">  stack       管理Docker堆栈</div><div class="line">  swarm       管理docker集群，包括创建、加入、退出、更新等</div><div class="line">  system      管理Docker</div><div class="line">  trust       管理Docker镜像的信任问题</div><div class="line">  volume      管理docker的数据容器，包括查看、创建、删除等</div><div class="line"></div><div class="line">命令:</div><div class="line">  attach      添加到一个正在运行的容器</div><div class="line">  build       通过dockerfile创建一个镜像</div><div class="line">  commit      从容器的变更中生成一个新镜像</div><div class="line">  cp          在容器和宿主文件系统中复制文件和文件夹</div><div class="line">  create      创建一个新的容器(只创建不允许)</div><div class="line">  deploy      部署新堆栈或更新现有堆栈</div><div class="line">  diff        在容器中进行文件对比</div><div class="line">  events      获取服务器的实时事件</div><div class="line">  exec        在容器中运行命令</div><div class="line">  export      将一个容器的文件以tar压缩包的形式导出</div><div class="line">  history     显示镜像的历史记录</div><div class="line">  images      显示镜像列表</div><div class="line">  import      从本地文件中导入镜像</div><div class="line">  info        显示系统层的信息</div><div class="line">  inspect     显示更底层的容器、镜像和任务信息</div><div class="line">  kill        杀掉一个或多个正在运行的容器</div><div class="line">  load        加载容器</div><div class="line">  login       登录到一个镜像仓库</div><div class="line">  logout      退出镜像仓库</div><div class="line">  logs        获取容器的日志</div><div class="line">  pause       停止容器的进程</div><div class="line">  port        显示出容器的所有端口</div><div class="line">  ps          显示容器列表</div><div class="line">  pull        从镜像仓库中拉取一个镜像</div><div class="line">  push        将一个镜像推送到一个镜像仓库</div><div class="line">  rename      重命名一个容器</div><div class="line">  restart     重新启动容器</div><div class="line">  rm          移除容器</div><div class="line">  rmi         移除镜像</div><div class="line">  run         在容器中运行命令</div><div class="line">  save        将容器保存为一个压缩包</div><div class="line">  search      在docker hub中搜索镜像</div><div class="line">  start       启动容器</div><div class="line">  stats       显示实时的容器状态</div><div class="line">  stop        停止容器</div><div class="line">  tag         给镜像加标签</div><div class="line">  top         显示容器正在运行的进程</div><div class="line">  unpause     恢复容器中的所有进程</div><div class="line">  update      更新容器中的配置</div><div class="line">  version     显示docker的版本信息</div><div class="line">  wait        阻塞进程一直到容器被停止</div><div class="line"></div><div class="line">Run &apos;docker COMMAND --help&apos; for more information on a command.</div></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="https://blog.csdn.net/itguangit/article/details/80246071" target="_blank" rel="external">docker常用命令总结</a></p>
<p><a href="https://segmentfault.com/a/1190000012063374" target="_blank" rel="external">Docker常用命令</a></p>
<p><a href="https://www.cnblogs.com/hcduguo/p/5150807.html" target="_blank" rel="external">Docker常用命令大全</a></p>
<p><a href="https://docker_practice.gitee.io/" target="_blank" rel="external">Docker从入门到实践</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker基本命令&quot;&gt;&lt;a href=&quot;#Docker基本命令&quot; class=&quot;headerlink&quot; title=&quot;Docker基本命令&quot;&gt;&lt;/a&gt;Docker基本命令&lt;/h1&gt;&lt;p&gt;Docker命令分为两大类：客户端命令和服务端命令。前者主要是操作接口，后者
    
    </summary>
    
      <category term="读书笔记" scheme="http://webfuse.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="http://webfuse.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>SpringFramework常用的注解说明</title>
    <link href="http://webfuse.cn/2018/09/28/SpringFramework%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E/"/>
    <id>http://webfuse.cn/2018/09/28/SpringFramework常用的注解说明/</id>
    <published>2018-09-28T10:59:34.000Z</published>
    <updated>2018-09-29T01:29:10.958Z</updated>
    
    <content type="html"><![CDATA[<p>在进行SpringBoot开发的时候经常要用到注解，有的时候很容易忘记某个注解的意思，现将一些常用的注解说明归纳如下：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Required</td>
<td>@Required注解检查。但它只检查属性是否已经设置而不会测试属性是否非空。@Required只能设置在setter方法上</td>
</tr>
<tr>
<td>@Autowired</td>
<td>Spring提供的注入工具【由Spring的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入】</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>如果需要byName（byName就是通过id去标识）注入，增加@Qualifier注释。一般在候选Bean数目不为1时应该加@Qualifier注释。</td>
</tr>
<tr>
<td>@Configuration</td>
<td>在用于指定配置信息的类上加上 @Configuration 注解，以明确指出该类是 Bean 配置的信息源。</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>@ComponentScan告诉Spring 哪个packages 的用注解标识的类 会被spring自动扫描并且装入bean容器</td>
</tr>
<tr>
<td>@Bean</td>
<td>@Bean注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。</td>
</tr>
<tr>
<td>@Lazy</td>
<td>如果我们想要 Spring 在启动的时候延迟加载 bean，即在调用某个 bean 的时候再去初始化，那么就可以使用 @Lazy 注解。</td>
</tr>
<tr>
<td>@Value</td>
<td>使用@Value注解，可以直接将属性值注入到beans中。</td>
</tr>
<tr>
<td>@Resource</td>
<td>@Resource用法与@Autowired 用法 用法相似，也是做依赖注入的，从容器中自动获取bean。</td>
</tr>
<tr>
<td>@Inject</td>
<td>这是jsr330中的规范，通过‘AutowiredAnnotationBeanPostProcessor’ 类实现的依赖注入。</td>
</tr>
<tr>
<td>@PropertySource</td>
<td>指定文件地址。提供了一种方便的、声明性的机制，用于向Spring的环境添加PropertySource。与@configuration类一起使用。</td>
</tr>
<tr>
<td>@PostConstruct</td>
<td>标注在方法上，该方法在构造函数执行完成之后执行。</td>
</tr>
<tr>
<td>@PreDestroy</td>
<td>标注在方法上，该方法在对象销毁之前执行。</td>
</tr>
<tr>
<td>@ActiveProfiles</td>
<td>用来声明活动的profile–@ActiveProfiles(“prod”(这个prod定义在配置类中))</td>
</tr>
<tr>
<td>@Profile</td>
<td>表示当一个或多个指定的文件是活动的时，一个组件是有资格注册的。使用@Profile注解类或者方法，达到在不同情况下选择实例化不同的Bean。@Profile(“dev”)表示为dev时实例化。</td>
</tr>
<tr>
<td>@Component</td>
<td>表示一个带注释的类是一个“组件”，成为Spring管理的Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component还是一个元注解。</td>
</tr>
<tr>
<td>@Controller</td>
<td>组合注解（组合了@Component注解），应用在MVC层（控制层）,DispatcherServlet会自动扫描注解了此注解的类，然后将web请求映射到注解了@RequestMapping的方法上。</td>
</tr>
<tr>
<td>@Service</td>
<td>组合注解（组合了@Component注解），应用在service层（业务逻辑层）</td>
</tr>
<tr>
<td>@Reponsitory</td>
<td>组合注解（组合了@Component注解），应用在dao层（数据访问层）</td>
</tr>
<tr>
<td>@RestController</td>
<td>@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用。</td>
</tr>
<tr>
<td>@ResponseBody</td>
<td>将返回值放在response体内。返回的是数据而不是页面</td>
</tr>
<tr>
<td>@RequestBody</td>
<td>允许request的参数在request体中，而不是在直接链接在地址的后面。此注解放置在参数前。</td>
</tr>
<tr>
<td>@PathVariable</td>
<td>放置在参数前，用来接受路径参数。</td>
</tr>
<tr>
<td>@ModelAttribute</td>
<td>将键值对添加到全局，所有注解了@RequestMapping的方法可获得次键值对（就是在请求到达之前，往model里addAttribute一对name-value而已）。</td>
</tr>
<tr>
<td>@RequestAttribute</td>
<td>注解<code>@RequestAttribute</code>可以被用于访问由过滤器或拦截器创建的、预先存在的请求属性</td>
</tr>
<tr>
<td>@RequestHeader</td>
<td>获得指定的请求中的Header信息</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>请求参数绑定</td>
</tr>
<tr>
<td>@ResponseStatus</td>
<td>带有@ResponseStatus注解的异常类会被ResponseStatusExceptionResolver 解析。可以实现自定义的一些异常,同时在页面上进行显示。</td>
</tr>
<tr>
<td>@CookieValue</td>
<td>用来获取Cookie中的值</td>
</tr>
<tr>
<td>@CrossOrigin</td>
<td>@CrossOrigin是用来处理跨域请求的注解</td>
</tr>
<tr>
<td>@RequestMapping</td>
<td>用来映射web请求（访问路径和参数），处理类和方法的。可以注解在类和方法上，注解在方法上的@RequestMapping路径会继承注解在类上的路径。同时支持Serlvet的request和response作为参数，也支持对request和response的媒体类型进行配置。其中有value(路径)，produces(定义返回的媒体类型和字符集)，method(指定请求方式)等属性。</td>
</tr>
<tr>
<td>@GetMapping</td>
<td>GET请求</td>
</tr>
<tr>
<td>@PostMapping</td>
<td>POST请求</td>
</tr>
<tr>
<td>@PutMapping</td>
<td>PUT请求</td>
</tr>
<tr>
<td>@PatchMapping</td>
<td>PATCH请求</td>
</tr>
<tr>
<td>@DeleteMapping</td>
<td>DELETE请求</td>
</tr>
<tr>
<td>@ExceptionHandler</td>
<td>用在方法上定义全局处理，通过他的value属性可以过滤拦截的条件：@ExceptionHandler(value=Exception.class)–表示拦截所有的Exception。</td>
</tr>
<tr>
<td>@ControllerAdvice</td>
<td>用在类上，声明一个控制器建言，它也组合了@Component注解，会自动注册为Spring的Bean</td>
</tr>
<tr>
<td>@InitBinder</td>
<td>通过@InitBinder注解定制WebDataBinder（用在方法上，方法有一个WebDataBinder作为参数，用WebDataBinder在方法内定制数据绑定，例如可以忽略request传过来的参数Id等）。</td>
</tr>
<tr>
<td>@SessionAttribute</td>
<td>@SessionAttribute作用于处理器类上，用于在多个请求之间传递参数，类似于Session的Attribute，但不完全一样，一般来说@SessionAttribute设置的参数只用于暂时的传递，而不是长期的保存，长期保存的数据还是要放到Session中。</td>
</tr>
<tr>
<td>@SessionAttributes</td>
<td>@sessionattributes注解应用到Controller上面，可以将Model中的属性同步到session当中。</td>
</tr>
<tr>
<td>@Aspect</td>
<td>声明一个切面（就是说这是一个额外功能）</td>
</tr>
<tr>
<td>@After</td>
<td>后置建言（advice），在原方法前执行。</td>
</tr>
<tr>
<td>@Before</td>
<td>前置建言（advice），在原方法后执行。</td>
</tr>
<tr>
<td>@Around</td>
<td>环绕建言（advice），在原方法执行前执行，在原方法执行后再执行（@Around可以实现其他两种advice）</td>
</tr>
<tr>
<td>@PointCut</td>
<td>声明切点，即定义拦截规则，确定有哪些方法会被切入</td>
</tr>
<tr>
<td>@EnableAspectJAutoProxy</td>
<td>开启Spring对AspectJ的支持</td>
</tr>
<tr>
<td>@SpingBootApplication</td>
<td>SpringBoot的核心注解，主要目的是开启自动配置。它也是一个组合注解，主要组合了@Configurer，@EnableAutoConfiguration（核心）和@ComponentScan。可以通过@SpringBootApplication(exclude={想要关闭的自动配置的类名.class})来关闭特定的自动配置。</td>
</tr>
<tr>
<td>@Async</td>
<td>注解在方法上标示这是一个异步方法，在类上标示这个类所有的方法都是异步方法。</td>
</tr>
<tr>
<td>@EnableAsync</td>
<td>开启异步任务支持。注解在配置类上。</td>
</tr>
<tr>
<td>@Scheduled</td>
<td>注解在方法上，声明该方法是计划任务。支持多种类型的计划任务：cron,fixDelay,fixRate</td>
</tr>
<tr>
<td>@EnableScheduling</td>
<td>注解在配置类上，开启对计划任务的支持。</td>
</tr>
<tr>
<td>@EnableAutoConfiguration</td>
<td>此注释自动载入应用程序所需的所有Bean——这依赖于Spring Boot在类路径中的查找。该注解组合了@Import注解，@Import注解导入了EnableAutoCofigurationImportSelector类，它使用SpringFactoriesLoader.loaderFactoryNames方法来扫描具有META-INF/spring.factories文件的jar包。而spring.factories里声明了有哪些自动配置。</td>
</tr>
<tr>
<td>@WebAppConfiguration</td>
<td>一般用在测试上，注解在类上，用来声明加载的ApplicationContext是一个WebApplicationContext。他的属性指定的是Web资源的位置，默认为src/main/webapp,我们可以修改为：@WebAppConfiguration(“src/main/resources”)。</td>
</tr>
<tr>
<td>@Cacheable</td>
<td>声明数据缓存</td>
</tr>
<tr>
<td>@EnableWebMvc</td>
<td>用在配置类上，开启SpringMvc的Mvc的一些默认配置：如ViewResolver，MessageConverter等。同时在自己定制SpringMvc的相关配置时需要做到两点：1.配置类继承WebMvcConfigurerAdapter类<br>2.就是必须使用这个@EnableWebMvc注解。</td>
</tr>
<tr>
<td>@BeforeTransaction</td>
<td>@BeforeTransaction在事务之前执行</td>
</tr>
<tr>
<td>@AfterTransaction</td>
<td>@AfterTransaction在事务之后执行</td>
</tr>
<tr>
<td>@Transactional</td>
<td>声明事务（一般默认配置即可满足要求，当然也可以自定义）</td>
</tr>
<tr>
<td>@ImportResource</td>
<td>虽然Spring提倡零配置，但是还是提供了对xml文件的支持，这个注解就是用来加载xml配置的。</td>
</tr>
<tr>
<td>@ConfigurationProperties</td>
<td>将properties属性与一个Bean及其属性相关联，从而实现类型安全的配置。</td>
</tr>
<tr>
<td>@Conditional</td>
<td>根据满足某一特定条件创建特定的Bean</td>
</tr>
<tr>
<td>@ConditionalOnBean</td>
<td>条件注解。当容器里有指定Bean的条件下。</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>条件注解。当类路径下有指定的类的条件下。</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>条件注解。基于SpEL表达式作为判断条件。</td>
</tr>
<tr>
<td>@ConditionalOnJava</td>
<td>条件注解。基于JVM版本作为判断条件。</td>
</tr>
<tr>
<td>@ConditionalOnJndi</td>
<td>条件注解。在JNDI存在的条件下查找指定的位置。</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>条件注解。当容器里没有指定Bean的情况下。</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>条件注解。当类路径下没有指定的类的情况下。</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>条件注解。当前项目不是web项目的条件下。</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>条件注解。类路径是否有指定的值。</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>条件注解。当指定Bean在容器中只有一个，后者虽然有多个但是指定首选的Bean。</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>条件注解。当前项目是web项目的情况下。</td>
</tr>
<tr>
<td>@EnableConfigurationProperties</td>
<td>注解在类上，声明开启属性注入，使用@Autowired注入。</td>
</tr>
<tr>
<td>@AutoConfigureAfter</td>
<td>在指定的自动配置类之后再配置。</td>
</tr>
<tr>
<td>@AutoConfigureBefore</td>
<td>在指定的自动配置类之前进行配置。</td>
</tr>
<tr>
<td>@RunWith</td>
<td>这个是Junit的注解，springboot集成了junit。一般在测试类里使用。</td>
</tr>
<tr>
<td>@ContextConfiguration</td>
<td>用来加载配置ApplicationContext，其中classes属性用来加载配置</td>
</tr>
</tbody>
</table>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_37490221/article/details/78406810" target="_blank" rel="external">Spring 注解大全与详解</a></li>
<li><a href="https://skyao.gitbooks.io/learning-spring-boot/content/" target="_blank" rel="external">Spring Boot学习笔记</a></li>
<li><a href="https://springframework.guru/spring-framework-annotations/" target="_blank" rel="external">SPRING FRAMEWORK ANNOTATIONS</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行SpringBoot开发的时候经常要用到注解，有的时候很容易忘记某个注解的意思，现将一些常用的注解说明归纳如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;注解&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;

    
    </summary>
    
      <category term="SpringBoot" scheme="http://webfuse.cn/categories/SpringBoot/"/>
    
    
      <category term="Spring" scheme="http://webfuse.cn/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://webfuse.cn/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术概览</title>
    <link href="http://webfuse.cn/2018/09/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/"/>
    <id>http://webfuse.cn/2018/09/03/区块链技术概览/</id>
    <published>2018-09-03T15:19:11.000Z</published>
    <updated>2018-09-03T15:28:55.804Z</updated>
    
    <content type="html"><![CDATA[<p>本文摘自《白话区块链》</p>
<h2 id="区块链技术理念"><a href="#区块链技术理念" class="headerlink" title="区块链技术理念"></a>区块链技术理念</h2><p><strong>区块链的本质就是一种记账方法，是通过“区块链客户端”来记账。运行中的客户端软件称为“节点”。</strong></p>
<p>在区块链系统中，所有的节点都是可以互相通信的，这个功能称为“<strong>网络路由</strong>”</p>
<p><strong>共识算法</strong>就是一种大家都遵守的筛选方案。在选出一个节点后，则一段时间内的账务数据都以这个节点记录为准，这个节点记录后会广播出去，告诉其他的节点，其他节点只需要通过网络来接收新的数据，接收后各自根据自己现有的账本验证一下能不能接得上，有没有不匹配和不规范的，如果都符合要求，就存储到自己的账本中。</p>
<p>有些区块链系统在记账环节会设计出一种带有竞争的机制，让各个节点去抢，谁抢到这个机会谁就能获得打包数据的权利并且同时获得这笔奖励。这个过程称为“<strong>挖矿</strong>”。</p>
<p>在区块链系统中，识别不同的使用者是通过一种密码算法来实现的。这个算法分为公钥和私钥，公钥可以给别人，私钥自己保管。公钥是用来做身份识别的，从公钥可以算出地址来代表一个用户。用公钥加密的数据必须用对应的私钥才能解密，用私钥加密（通常称为“签名”）的数据必须用对应的公钥才能解密。</p>
<h2 id="区块链技术栈"><a href="#区块链技术栈" class="headerlink" title="区块链技术栈"></a>区块链技术栈</h2><p>区块链是将产生的数据按照一定的时间间隔，分成一个个的数据块记录，然后再根据数据块大的先后关系串联起来。</p>
<p><strong>区块链的基本技术：区块链账本、共识机制、密码算法、网络路由、脚本系统。</strong></p>
<p>区块链账本：表示一种特有的数据记录格式。每一个数据块之间通过某个标志连接起来，从而形成一条链。区块数据在逻辑上分成了区块头和区块体。每个区块头中通过梅克尔根关联了区块体众多的交易事务，每个区块之间通过区块头哈希值串联起来。</p>
<p>共识算法：在区块链系统中，每个节点必须要做的事情就是让自己的账本跟其他节点的账本保持一致。共识算法就是一个规则，每个节点都按照这个规则去确认各自的数据。共识算法其实也是一种筛选方案，比如PoW（Proof  of Work，工作量证明）、PoS（Proof of Stake，权益证明）、DPoS（Delegate Proof of Stake，委托权益证明）、PBFT（Practical Byzantine Fault Tolerance，实用拜占庭容错算法）等。</p>
<p>密码算法：主要用到，哈希算法、梅克尔树。</p>
<p>脚本系统：脚本系统可以使区块链中实现各种各样的业务功能。</p>
<p>网络路由：区块链系统是一个分布式系统，各个节点之间的通信靠的就是网络路由。</p>
<h2 id="区块链分类和架构"><a href="#区块链分类和架构" class="headerlink" title="区块链分类和架构"></a>区块链分类和架构</h2><p>区块链系统实际上是一个维护公共数据账本的系统，一切技术单元的设计都是为了更好地维护这个公共数据账本。通过共识算法达成节点的账本数据一致；通过密码算法确保账本数据的不可篡改性以及数据发送的安全性；通过脚本系统扩展账本数据的表达范畴。区块链系统实际上就是一种特别设计的数据库系统或者说分布式数据库系统。</p>
<h3 id="区块链1-0架构"><a href="#区块链1-0架构" class="headerlink" title="区块链1.0架构"></a>区块链1.0架构</h3><p>这个阶段的区块链系统主要是用来实现数字货币的。</p>
<img src="/2018/09/03/区块链技术概览/blockchain-1.0.png" alt="blockchain-1.0.png" title="">
<p>矿工要对区块数据进行打包；矿工能获得系统的奖励。<br>钱包工具提供给用户管理自己账户地址以及余额。<br>浏览器用来查看当前区块链网络中发送的数据情况（比如，最新区块高度、内存池的交易数等）<br>RPC客户端和命令行接口用来访问核心节点</p>
<h3 id="区块链2-0架构"><a href="#区块链2-0架构" class="headerlink" title="区块链2.0架构"></a>区块链2.0架构</h3><p>区块链2.0的代表产品是以太坊。最大的区别是支持智能合约，用时拥有以太坊虚拟机</p>
<img src="/2018/09/03/区块链技术概览/blockchain-2.0.png" alt="blockchain-2.0.png" title="">
<h3 id="区块链3-0架构"><a href="#区块链3-0架构" class="headerlink" title="区块链3.0架构"></a>区块链3.0架构</h3><p>区块链3.0是将区块链技术作为一种泛解决方案，可以面向行业应用。</p>
<img src="/2018/09/03/区块链技术概览/blockchain-3.0.png" alt="blockchain-3.0.png" title="">
<p>区块链3.0可以看做是一套框架，通过对框架的配置和二次开发可以适应各行业的需求。“可插拔共识”意思就是共识机制是不固定的，可配置的。</p>
<h2 id="区块链分类"><a href="#区块链分类" class="headerlink" title="区块链分类"></a>区块链分类</h2><h3 id="根据网络范围分类："><a href="#根据网络范围分类：" class="headerlink" title="根据网络范围分类："></a>根据网络范围分类：</h3><ul>
<li>公有链：完全对外开放的，任何人都可以使用，没有权限的设定，完全公开透明。没有第三方管理、依靠一组事先约定好的规则。这个规则确保每个参与者在不信任的网络环境中能够发起可靠的交易事务。</li>
<li>私有链：不对外开放，仅仅在组织内部使用。</li>
<li>联盟链：网络范围介于公有链和私有链之间。使用在多个成员角色的环境中，如银行之间的支付结算、企业之间的物流等。</li>
</ul>
<h3 id="根据部署环境分类："><a href="#根据部署环境分类：" class="headerlink" title="根据部署环境分类："></a>根据部署环境分类：</h3><ul>
<li>主链：部署在生产环境的真正的区块链系统。</li>
<li>测试链：开发者为了方便大家学习使用而提供的测试用途的区块链网络。</li>
</ul>
<h3 id="根据对接类型分类："><a href="#根据对接类型分类：" class="headerlink" title="根据对接类型分类："></a>根据对接类型分类：</h3><ul>
<li>单链：能够单独运行的区块链系统都称为“单链”。比如：比特币主链、测试链，以太坊主链、测试链。</li>
<li>侧链：属于一种区块链的跨链技术。</li>
<li>互联链：所有的区块链都互联起来（只能说是如果可以的话）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文摘自《白话区块链》&lt;/p&gt;
&lt;h2 id=&quot;区块链技术理念&quot;&gt;&lt;a href=&quot;#区块链技术理念&quot; class=&quot;headerlink&quot; title=&quot;区块链技术理念&quot;&gt;&lt;/a&gt;区块链技术理念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;区块链的本质就是一种记账方法，是通过“区块链客
    
    </summary>
    
      <category term="区块链" scheme="http://webfuse.cn/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://webfuse.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>以太坊学习摘要</title>
    <link href="http://webfuse.cn/2018/08/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    <id>http://webfuse.cn/2018/08/24/以太坊学习摘要/</id>
    <published>2018-08-24T14:05:11.000Z</published>
    <updated>2018-08-24T16:26:56.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h2><p>以太坊（Ethereum）是一个建立在区块链技术之上， 去中心化应用平台。它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。与比特币相比，以太坊属于区块链2.0的范畴。</p>
<p>从平台角度来看，以太坊类似于苹果或者安卓的应用商店；从技术角度来说，以太坊类似于一个区块链操作系统。</p>
<p>下图是以太坊的组成：</p>
<img src="/2018/08/24/以太坊学习摘要/以太坊组成.png" alt="以太坊组成.png" title="">
<p>所以，可以理解为：“以太坊=区块链+智能合约”。开发者在以太坊上可以开发任意的应用，实现任意的智能合约。以太坊的虚拟机和智能合约扩展了外部应用程序在区块链技术上的应用。另外，以太坊中的智能合约是运行在虚拟机（也就是EVM，Ethereum Virtual Machine，以太坊虚拟机）上的。</p>
<h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>智能合约就是以太坊上的程序，它是代码和数据（状态）的集合。所以，不管什么样功能的合约，站在技术的角度上来讲，就是通过执行一组程序改变了一些值。</p>
<p>我们不但可以实现数字货币，还可以实现众筹合约、担保合约、融资租赁合约、期货合约以及各种金融与非金融的订单合约。</p>
<p>在以太坊中，每个合约都有一个唯一的地址来标识它自己（由创建者的哈希地址和曾经发送过的交易的数量推算出来）。客户端可以与这个地址进行交互，可以发送ether，调用函数，查询当前的状态等。</p>
<p>有三种常见的智能合约语言，这些语言可以被编译成智能合约运行在以太坊虚拟矿机上。它们是：</p>
<ul>
<li>Solidity：和Javascript语言类似。这是目前最受欢迎的和功能丰富的智能合约脚本语言。</li>
<li>Serpent：和Python语言类似，在以太坊历史的早期受欢迎。</li>
<li>LLL (Lisp Like Language)：和Lisp类似，只有在早期使用。它大概是最难用的。</li>
</ul>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>状态可以理解为以太坊中的某些内容发生变化。</p>
<p>对于区块链账本，这里的变化可以指一笔转账，也可以是合约的某个规则被激活等，总之就是数据动了，以太坊中将变化的过程称为<strong>状态转变函数</strong></p>
<p>在以太坊系统中，状态是由被称为“账户”的对象和在两个账户之间转移价值和信息的状态转换构成的。</p>
<blockquote>
<p>以太坊的每个区块头中都包含了指向三棵树（状态树、交易树、数据树）的指针。</p>
</blockquote>
<h2 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h2><p>以太坊具有账户的概念。在以太坊中有两类的账户：外部账户 和 合约账户。</p>
<h3 id="外部账户"><a href="#外部账户" class="headerlink" title="外部账户"></a>外部账户</h3><p>外部账户（EOA，Externally Owned Account）,它就是一个一般账户的概念。外部账户是由一对秘钥定义的，一个私钥一个公钥，公钥的后20位作为地址。</p>
<p>外部账户没有关联任何的代码。</p>
<h3 id="合约账户"><a href="#合约账户" class="headerlink" title="合约账户"></a>合约账户</h3><p>智能合约的部署是指把合约字节码发布到区块链上，并使用一个特定的地址来标示这个合约，这个地址称为合约账户。合约账户是可编程的，可以执行图灵完备的计算任务，合约账户之间可以传递消息。</p>
<h3 id="区别和联系"><a href="#区别和联系" class="headerlink" title="区别和联系"></a>区别和联系</h3><p>合约账户的地址是通过合约创建者的地址和该地址发出过的交易数量计算得到的。</p>
<p>一个外部账户可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部账户或合约账户。</p>
<p>在两个外部账户之间传送消息是价值转移的过程。但从外部账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。</p>
<p>只有当外部账户发出指令时，合同账户才会执行相应的操作。</p>
<h3 id="账户的结构"><a href="#账户的结构" class="headerlink" title="账户的结构"></a>账户的结构</h3><p>以太坊中的账户包含以下4个部分：</p>
<ul>
<li>随机数（Nonce）。用于确定每笔交易智能被处理一次的计数器，也就是每个账户的交易计数，用于防止重放攻击。当某个账户发送一笔交易时，根据已生成的交易数来累加这个数字。</li>
<li>账户目前的以太币余额（Balance）。</li>
<li>账户的存储（Root），它是一个哈希值，指向的是一棵patricia trie（帕夏尔前缀树）。默认为空</li>
<li>账户的合约代码（CodeHash），只有合约账户才有，否则为空。</li>
</ul>
<h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>以太坊中的交易就是状态的转换过程。</p>
<p>交易在以太坊中是在签名的数据包，这个数据包中存储了从外部账户发送的消息。所谓的交易就是一个消息，这个消息被发送者签名了。</p>
<h3 id="交易类型："><a href="#交易类型：" class="headerlink" title="交易类型："></a>交易类型：</h3><ul>
<li>转账交易。也就是从一个账户往另一个账户转账发以太币。</li>
<li>合约创建交易。也就是创建一个合约，因为创建合约也要消耗以太坊。</li>
<li>合约执行交易。在以太坊中，执行合约也算一种交易。</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>AccountNonce：表明交易的发送者已经发送过的交易数，与账户中定义的随机数对应。</li>
<li>Price和GasLimit：用来抵抗拒绝服务攻击。就是为了让交易的执行带上成本，每进行一次交易都要支付一定的手续费，GasLimit是交易执行所需的计算量，Price是单价，两者的乘积就是手续费。如果交易在执行的过程中实际所需的消耗超出了Gas限制就会出错回滚，如果存在多余的Gas就会退还多余部分。</li>
<li>Recipient：接收方的地址。</li>
<li>Amount：发送的以太坊金额，单位wei。</li>
<li>Payload：交易携带的数据，根据不同的交易类型有不同的用法。</li>
<li>V、R、S：交易的签名数字。</li>
</ul>
<blockquote>
<p>以太坊的区块头中有交易信息。</p>
</blockquote>
<h3 id="计量单位"><a href="#计量单位" class="headerlink" title="计量单位"></a>计量单位</h3><p>最小单位是wei。1 ether = 1000 000 000 000 000 000 wei。</p>
<blockquote>
<p>kwei = 1000wei</p>
<p>mwei = 1000kwei</p>
<p>gwei = 1000mwei</p>
<p>szabo = 1000gwei</p>
<p>finney = 1000szabo</p>
<p>ether = 1000finney</p>
</blockquote>
<h2 id="收据"><a href="#收据" class="headerlink" title="收据"></a>收据</h2><p>在以太坊中，收据是指每条交易执行所影响的数据条，在以太坊的区块头中存储了收据树的根哈希值。</p>
<p>收据实际上是一个数据的统计记录，记录了执行后的特征数据。</p>
<p>数据结构如下：</p>
<ul>
<li>PostState： 状态树的根哈希。通过这个字段使得收据可以直接访问都状态数据。</li>
<li>CumulativeGasUsed：累计的Gas消耗，包含关联的本条交易以及之前的交易所消耗的Gas之和，或者说是指所在区域的Gas消耗之和。</li>
<li>TxHash：交易事务的哈希值。</li>
<li>ContractAddress：合约地址，如果是普通的转账交易则为空。</li>
<li>GasUsed：本条交易消耗的Gas。</li>
</ul>
<h2 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h2><p>在以太坊中Gas可以理解为在以太坊平台上执行程序需要付出的成本或者手续费。</p>
<p>Gas是通过以太坊中合约的执行计算量来决定的，这个计算量可以简单理解为是算力的消耗，执行一次SHA3哈希计算会消耗20个Gas，执行一次普通的转账交易就要消耗21000个Gas。</p>
<p>以太币总额 = 消耗的Gas ✖️ Gas单价。</p>
<h2 id="以太坊客户端"><a href="#以太坊客户端" class="headerlink" title="以太坊客户端"></a>以太坊客户端</h2><p>以太坊客户端，其实我们可以把它理解为一个开发者工具，它提供账户管理、挖矿、转账、智能合约的部署和执行等等功能。</p>
<p>go-ethereum是官方的Go语言客户端。可用于挖矿、组件私有链、管理账号、部署智能合约等。它提供了一个交互式命令控制台，通过命令控制台中包含了以太坊的各种功能（API）。</p>
<p>除go-ethereum外，官方还提供了cpp-ethereum，基于C++写的。</p>
<h2 id="以太坊网络"><a href="#以太坊网络" class="headerlink" title="以太坊网络"></a>以太坊网络</h2><p>我们可以把以太网络分为3种：主网、测试网络和私有网络。</p>
<ul>
<li>生产环境网络（主网）: 以太坊的生产网络顾名思义，也就是产生真正有价值的 的以太币的网络。</li>
<li>测试网络: 以太坊的测试网络也是官方提供的，顾名思义就是专供用户来开发、调试和测试的。上面的合约执行不消耗真实的以太币。官方提供的为：Rinkeby</li>
<li>私有网络：以太坊的私有网络，顾名思义就是由用户自己创建的私有网络。</li>
</ul>
<h2 id="以太币"><a href="#以太币" class="headerlink" title="以太币"></a>以太币</h2><p>以太币每年的产量则是固定的。</p>
<p>以太币的数量以这种形式存在：Pre-mine（矿前） + Block rewards（区块奖励） + Uncle rewards（叔块奖励） + Uncle referencing rewards（叔块引用奖励）</p>
<ul>
<li>矿前：2014年7月/8月间，为众筹大约发行了7200万以太币。这些币有的时候被称之为“矿前”。众筹阶段之后，以太币每年的产量被限制在7200万以太币的25%（每年以太币的矿产量，不高于1800万，除了一次性为crowdsale而发行的7200万以太币）</li>
<li>区块奖励：每产生一个新区块就会产生5个新以太币。每年有225万个区块被挖出来，每个区块5个以太币，也就是每年会产出1130万个以太币。</li>
<li>叔块奖励：有些区块被挖得稍晚一些，因此不能称为主区块链的组成部分，以太币称它们为“ uncles”，并且在之后的区块中，可以引用它们。如果uncles在之后的区块链中作为叔块被引用，每个叔块会为挖矿者产出大约4.375个以太币（5个以太币奖励的8分之7）.这被称之为叔块奖励。</li>
<li>叔块引用奖励：矿工每引用一个叔块，就得到了大约0.15个以太币（最多引用两个叔块）。</li>
</ul>
<hr>
<p>引用：</p>
<ul>
<li>《白话区块链》</li>
<li><a href="https://github.com/ethereum/wiki/wiki/%5B%E4%B8%AD%E6%96%87%5D-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6" target="_blank" rel="external">以太坊白皮书</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24012669" target="_blank" rel="external">一个基础的以太坊介绍</a></li>
<li><a href="https://learnblockchain.cn/2017/11/20/whatiseth/" target="_blank" rel="external">以太坊是什么 - 以太坊开发入门指南</a></li>
<li><a href="http://me.tryblockchain.org/getting-up-to-speed-on-ethereum.html" target="_blank" rel="external">以太坊开发入门，完整入门篇</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;以太坊&quot;&gt;&lt;a href=&quot;#以太坊&quot; class=&quot;headerlink&quot; title=&quot;以太坊&quot;&gt;&lt;/a&gt;以太坊&lt;/h2&gt;&lt;p&gt;以太坊（Ethereum）是一个建立在区块链技术之上， 去中心化应用平台。它允许任何人在平台中建立和使用通过区块链技术运行的去中心化
    
    </summary>
    
      <category term="区块链" scheme="http://webfuse.cn/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://webfuse.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="http://webfuse.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>离职前夕的随想</title>
    <link href="http://webfuse.cn/2018/07/25/%E7%A6%BB%E8%81%8C%E5%89%8D%E5%A4%95%E7%9A%84%E9%9A%8F%E6%83%B3/"/>
    <id>http://webfuse.cn/2018/07/25/离职前夕的随想/</id>
    <published>2018-07-24T16:03:21.000Z</published>
    <updated>2018-07-28T03:19:46.941Z</updated>
    
    <content type="html"><![CDATA[<p>去年，离开ND后的第一天，在去临海的动车上，写了《十年》一文。没想到的是今年，在离开德诺的前一天晚上，又写下了一篇类似的文章。</p>
<p>离开德诺不舍是真，但是浓浓的不甘也是真。故事终究是有聚有散，事情也无法分辨谁对谁错，无非就是那一时刻的选择而已。</p>
<p>最近在看《少有人走的路》，也就刚看了第一章，也许明天开始又会重新从头开始看，不为别的，只是觉得第一章就已经很和我口味了。一年来，特别是今年以来的一些事情让我很无语，其实，现在想来也是自己的问题罢了。“我的时间是我的责任，是我，只有我，能决定怎么安排和利用我的时间”，同理，他人的时间应该也是他人负责，旁人无法左右。</p>
<p>最后，引用“自律是解决人生问题最主要的工具，也是消除人生痛苦最重要的方法。”这句来做个结束吧！希望，新的开始是自己想要的开始，新的征程是充满激情的征程~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年，离开ND后的第一天，在去临海的动车上，写了《十年》一文。没想到的是今年，在离开德诺的前一天晚上，又写下了一篇类似的文章。&lt;/p&gt;
&lt;p&gt;离开德诺不舍是真，但是浓浓的不甘也是真。故事终究是有聚有散，事情也无法分辨谁对谁错，无非就是那一时刻的选择而已。&lt;/p&gt;
&lt;p&gt;最近
    
    </summary>
    
      <category term="未分类" scheme="http://webfuse.cn/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="生活" scheme="http://webfuse.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="杂念" scheme="http://webfuse.cn/tags/%E6%9D%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Java面试手册</title>
    <link href="http://webfuse.cn/2018/07/22/Java%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C/"/>
    <id>http://webfuse.cn/2018/07/22/Java面试手册/</id>
    <published>2018-07-22T00:19:45.000Z</published>
    <updated>2018-07-28T03:19:46.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java面试手册"><a href="#Java面试手册" class="headerlink" title="Java面试手册"></a>Java面试手册</h1><p>《Java面试手册》整理了从业到现在看到的、经历过的一些Java面试题。</p>
<p>主要发布在我的GitHUb上，见：<a href="https://github.com/guanzhenxing/java_interview_manual" target="_blank" rel="external">Java面试手册</a></p>
<p>这些面试题的主要来源是一些网站还有github上的内容，由于平常在收藏到“印象笔记”中的时候没有保留来源出处，如果有介意版权的可以联系我。</p>
<p>主要分为以下部分：</p>
<ul>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/java-basic/index.md" target="_blank" rel="external">Java基础</a><ul>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/java-basic/oop.md" target="_blank" rel="external">面向对象</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/java-basic/basic.md" target="_blank" rel="external">基础</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/java-basic/collections.md" target="_blank" rel="external">集合</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/java-basic/multithread.md" target="_blank" rel="external">多线程</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/java-basic/jvm.md" target="_blank" rel="external">JVM</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/java-basic/nio.md" target="_blank" rel="external">NIO</a></li>
</ul>
</li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/design-pattern/index.md" target="_blank" rel="external">设计模式</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/data-structures-and-algorithms/index.md" target="_blank" rel="external">数据结构与算法</a><ul>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/data-structures-and-algorithms/algorithms.md" target="_blank" rel="external">算法</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/data-structures-and-algorithms/data-structures.md" target="_blank" rel="external">数据结构</a></li>
</ul>
</li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/java-web/index.md" target="_blank" rel="external">JavaWeb</a><ul>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/java-web/http.md" target="_blank" rel="external">HTTP基础</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/java-web/java-web-basic.md" target="_blank" rel="external">JavaWeb基础</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/java-web/spring.md" target="_blank" rel="external">Spring系列</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/java-web/mybatis.md" target="_blank" rel="external">MyBatis</a></li>
<li>Hibernate</li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/java-web/tomcat.md" target="_blank" rel="external">Tomcat</a></li>
</ul>
</li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/db-cache/index.md" target="_blank" rel="external">数据库与缓存</a><ul>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/db-cache/db_basic.md" target="_blank" rel="external">数据库基本理论</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/db-cache/cache_basic.md" target="_blank" rel="external">缓存基本理论</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/db-cacahe/db-index.md" target="_blank" rel="external">数据库索引</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/db-cache/sharding.md" target="_blank" rel="external">分库分表</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/db-cache/mysql.md" target="_blank" rel="external">MySQL</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/db-cache/mongodb.md" target="_blank" rel="external">MongoDB</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/db-cache/redis.md" target="_blank" rel="external">Redis</a></li>
</ul>
</li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/mq/index.md" target="_blank" rel="external">消息队列</a><ul>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/mq/basic.md" target="_blank" rel="external">MQ基础</a></li>
</ul>
</li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/distributed/index.md" target="_blank" rel="external">分布式</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/mic-service/index.md" target="_blank" rel="external">微服务</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/security-performance/index.md" target="_blank" rel="external">安全和性能</a><ul>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/security-performance/security.md" target="_blank" rel="external">安全</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/security-performance/performance.md" target="_blank" rel="external">性能</a></li>
</ul>
</li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/network-server/index.md" target="_blank" rel="external">网络与服务器</a><ul>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/network-server/network.md" target="_blank" rel="external">计算机网络</a></li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/network-server/nginx.md" target="_blank" rel="external">Nginx</a></li>
</ul>
</li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/software_engineering/index.md" target="_blank" rel="external">软件工程</a><ul>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/software_engineering-server/uml.md" target="_blank" rel="external">UML</a></li>
</ul>
</li>
<li><a href="https://github.com/guanzhenxing/java_interview_manual/blob/master/business/index.md" target="_blank" rel="external">业务</a></li>
</ul>
<hr>
<p>主要参考：</p>
<ul>
<li><a href="http://blog.720ui.com/2018/java_interview_final/" target="_blank" rel="external">Java面试通关要点汇总集【终极版】</a></li>
<li><a href="https://github.com/xingshaocheng/architect-awesome" target="_blank" rel="external">《后端架构师技术图谱》</a></li>
<li><code>https://github.com/hadyang/interview</code></li>
<li><code>https://github.com/crossoverJie/Java-Interview</code></li>
<li><a href="https://segmentfault.com/a/1190000012063898" target="_blank" rel="external">后台开发常问面试题集锦</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java面试手册&quot;&gt;&lt;a href=&quot;#Java面试手册&quot; class=&quot;headerlink&quot; title=&quot;Java面试手册&quot;&gt;&lt;/a&gt;Java面试手册&lt;/h1&gt;&lt;p&gt;《Java面试手册》整理了从业到现在看到的、经历过的一些Java面试题。&lt;/p&gt;
&lt;p&gt;主要
    
    </summary>
    
      <category term="读书笔记" scheme="http://webfuse.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://webfuse.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://webfuse.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基于Token的权限认证服务</title>
    <link href="http://webfuse.cn/2018/03/11/%E5%9F%BA%E4%BA%8EToken%E7%9A%84%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1/"/>
    <id>http://webfuse.cn/2018/03/11/基于Token的权限认证服务/</id>
    <published>2018-03-11T14:03:58.000Z</published>
    <updated>2018-07-28T03:19:46.930Z</updated>
    
    <content type="html"><![CDATA[<p>在这两年接触的项目基本上是基于前后端分离、多种后端服务组合而成的，这有别于先前的“单体”的项目，而且我们还需要考虑外部应用接入的场景、用户-服务的鉴权、服务-服务的鉴权等多种鉴权场景。</p>
<p>本方案基于客户端Token与网关结合的方式。所有的客户端请求都经过网关，网关将校验客户端发送上来的Token等信息，如果通过则转发给对应的服务，如果不通过则直接返回40X给客户端。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><img src="/2018/03/11/基于Token的权限认证服务/auth-arch.png" alt="auth-arch.png" title="">
<ol>
<li>获得authorize,用户/设备从UAA Service中获得authorize信息</li>
<li>附加mac token,请求在访问服务时候附加上mac token</li>
<li>Gateway进行认证，Gateway将收到的每个mac token发送给UAA Service进行校验</li>
<li>每个服务只有权限去操作自己负责的那部分功能（待规划）</li>
</ol>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><img src="/2018/03/11/基于Token的权限认证服务/auth-sequence.png" alt="auth-sequence.png" title="">
<ol>
<li>用户/客户端从UAA Service中获得Token</li>
<li>如果UAA Service中无此用户/客户端,则抛出AuthorizationException异常并返回401</li>
<li>如果UAA Service认证成功，返回对应的Token信息</li>
<li>用户的请求数据，请求头Authorization中带上Token信息</li>
<li>网关过滤所有的请求，携带Token、请求信息向UAA Service请求鉴权</li>
<li>如果UAA Service鉴权失败，抛出AuthenticationException异常并返回403</li>
<li>如果UAA Service鉴权成功，返回用户的权限等信息</li>
<li>网关向业务发起请求（此时，不携带授权信息。因为鉴权等都在网关处理了）</li>
<li>业务服务向微服务发起请求，同样也不携带授权信息</li>
<li>返回结果给用户</li>
</ol>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>根据开发阶段的鉴权、用户-服务的鉴权、服务-服务的鉴权等不同的场景，定义了三种方式的协议。</p>
<h3 id="Debug-Token协议"><a href="#Debug-Token协议" class="headerlink" title="Debug Token协议"></a>Debug Token协议</h3><p>debug token适用于在开发测试环境调试API。</p>
<h4 id="协议-1"><a href="#协议-1" class="headerlink" title="协议"></a>协议</h4><p>在Client发出api请求之前，必须将debug token的信息放在HTTP Header的Authorization里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Authorization:DEBUG userid=&quot;123456&quot;,realm=&quot;&quot;</div></pre></td></tr></table></figure>
<p>上面的代码中：</p>
<blockquote>
<p>userid为调试的用户</p>
<p>realm为可选字段，预定为用户所在的领域(应用、行业或者机构）</p>
</blockquote>
<h4 id="示例（伪代码）"><a href="#示例（伪代码）" class="headerlink" title="示例（伪代码）"></a>示例（伪代码）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GET /v0.1/resources HTTP/1.1</div><div class="line">Host: a.dynamax.io</div><div class="line">Accept: application/json</div><div class="line">Authorization: DEBUG userid=&apos;&apos;,realm=&apos;&apos;</div></pre></td></tr></table></figure>
<h3 id="Mac-Token协议"><a href="#Mac-Token协议" class="headerlink" title="Mac Token协议"></a>Mac Token协议</h3><p>mac token适用于不安全网络下的API授权</p>
<h4 id="协议-2"><a href="#协议-2" class="headerlink" title="协议"></a>协议</h4><p>通过“登录接口”可以获得Token。mac_token的数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;user_id&quot;:&quot;&quot;, //用户标识</div><div class="line">    &quot;access_token&quot;:&quot;&quot;, //token标识</div><div class="line">    &quot;expires_at&quot;:&quot;&quot;,    //本token的过期时间</div><div class="line">    &quot;refresh_token&quot;:&quot;&quot;,   //用以续期</div><div class="line">    &quot;mac_key&quot;:&quot;&quot;,   //hmac的密钥</div><div class="line">    &quot;mac_algorithm&quot;:&quot;hmac-sha-256&quot;  //hmac算法的名称</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>hmac算法见：[[<a href="https://tools.ietf.org/html/rfc2104" target="_blank" rel="external">https://tools.ietf.org/html/rfc2104</a>]]</p>
<p>在Client发出api请求之前，必须将mac token的信息放在HTTP Header的Authorization里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Authorization:MAC id=&quot;&quot;,nonce=&quot;&quot;,mac=&quot;&quot;</div></pre></td></tr></table></figure></p>
<p>上面的代码中：</p>
<blockquote>
<p>id为mac_token.access_token</p>
<p>nonce为 时间戳:随机码（客户端生成），有效时间+-5分钟</p>
<p>mac为请求签名： mac=base64(hmac(mac_token.mac_key,mac_token.mac_algorithm,request_content))</p>
<p>request_content = nonce + \n + http-method + \n + request-url + \n + host + \n </p>
<p>http-method，请求的方法，大写，如：GET</p>
<p>request-url，请求的地址（包含参数的部分，不包含域名部分），区分大小写，如/v0.1/databases</p>
<p>host，为HTTP Header中的host，区分大小写，如dynamax.io</p>
</blockquote>
<h4 id="示例-伪代码）"><a href="#示例-伪代码）" class="headerlink" title="示例(伪代码）"></a>示例(伪代码）</h4><p>获得token</p>
<p><strong>request</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST /v0.1/tokens HTTP/1.1</div><div class="line">Host: api.uaa.dynamax.io</div><div class="line">Accept: application/json</div><div class="line">Content-Type: application/json</div><div class="line">&#123;</div><div class="line">    &quot;username&quot;:&quot;330134&quot;,</div><div class="line">    &quot;password&quot;:&quot;******&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>reqponse</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 201 Created</div><div class="line">Content-Type: application/json;charset=UTF-8</div><div class="line">Cache-Control: no-store</div><div class="line">Pragma: no-Cache</div><div class="line">&#123;</div><div class="line">    &quot;user_id&quot;:&quot;&quot;,</div><div class="line">    &quot;access_token&quot;:&quot;&quot;,</div><div class="line">    &quot;expires_at&quot;:&quot;&quot;,</div><div class="line">    &quot;refresh_token&quot;:&quot;&quot;,</div><div class="line">    &quot;mac_key&quot;:&quot;&quot;,</div><div class="line">    &quot;mac_algorithm&quot;:&quot;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="访问资源"><a href="#访问资源" class="headerlink" title="访问资源"></a>访问资源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GET /v0.1/resources HTTP/1.1</div><div class="line">Host: resources.dynamax.io</div><div class="line">Accept: application/json</div><div class="line">Authorization:MAC id=&quot;adFeww3Fw4VV09876&quot;,nonce=&quot;1234234345343:adfasd32&quot;,mac=&quot;SDFS8weadfa42234&quot;</div></pre></td></tr></table></figure>
<h3 id="Bearer-Token协议"><a href="#Bearer-Token协议" class="headerlink" title="Bearer Token协议"></a>Bearer Token协议</h3><p>bearer token适用于安全网络下的api授权。也就是说，bearer适用于微服务之间的相互调用的api授权。</p>
<h4 id="协议-3"><a href="#协议-3" class="headerlink" title="协议"></a>协议</h4><p>可以通过“bearer_token”的接口获得相应的bearer_token，数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;user_id&quot;:&quot;&quot;, //用户标识</div><div class="line">&quot;access_token&quot;:&quot;&quot; //token标识</div><div class="line">&quot;expires_at&quot;:&quot;&quot; //本token的过期时间</div><div class="line">&quot;refresh_token&quot;:&quot;&quot; //用以续期</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Client发出api请求之前，必须将bearer token的信息放在HTTP Header的Authorization里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Authorization:BEARER &quot;XXX123XXXXX&quot; user_id:&quot;&quot;</div></pre></td></tr></table></figure>
<p>上面的代码中：</p>
<blockquote>
<p>“XXX123XXXXX”为bearer_token.access_token</p>
<p>user_id可选，该值位获得bearer token对应的账号。该值用来传递用户信息到其他服务端，用来判断是否有权限。</p>
</blockquote>
<h2 id="待优化的点"><a href="#待优化的点" class="headerlink" title="待优化的点"></a>待优化的点</h2><ul>
<li>怎么鉴定一个请求是否需要认证？白名单？</li>
<li>各个业务服务以及微服务是否需要再次认证？会不会出现绕过网关的情况？</li>
<li>所有的服务都通过网关，在UAA Service中进行鉴权，会不会造成UAA Service是个瓶颈点？</li>
<li>是否能够很方便地扩展到OAuth2？</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这两年接触的项目基本上是基于前后端分离、多种后端服务组合而成的，这有别于先前的“单体”的项目，而且我们还需要考虑外部应用接入的场景、用户-服务的鉴权、服务-服务的鉴权等多种鉴权场景。&lt;/p&gt;
&lt;p&gt;本方案基于客户端Token与网关结合的方式。所有的客户端请求都经过网关，网
    
    </summary>
    
      <category term="UAA" scheme="http://webfuse.cn/categories/UAA/"/>
    
    
      <category term="实战" scheme="http://webfuse.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="权限认证" scheme="http://webfuse.cn/tags/%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>RBAC实践</title>
    <link href="http://webfuse.cn/2018/03/01/RBAC%E5%AE%9E%E8%B7%B5/"/>
    <id>http://webfuse.cn/2018/03/01/RBAC实践/</id>
    <published>2018-03-01T14:34:42.000Z</published>
    <updated>2018-07-28T03:19:46.912Z</updated>
    
    <content type="html"><![CDATA[<p>RBAC，即大家很熟悉的“基于角色的访问控制”。理论什么的这里就不讲了，重点介绍下一种基于RBAC的实践。</p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li>领域：Realm，角色的定义范围。</li>
<li>角色：Role，一组权限的集合。角色必须定义在指定领域内</li>
<li>资源：Resource，主要应用于前端UI元素可见性方面的权限管控</li>
<li>操作：Action，主要应用于服务端api调用合法性方面的管控</li>
<li>权限：Permission，一组“资源+操作”的组合，并具备一个用户易于理解的名称</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="角色-ROLE-INFO"><a href="#角色-ROLE-INFO" class="headerlink" title="角色 ROLE_INFO"></a>角色 ROLE_INFO</h3><pre><code>{
    &quot;id&quot;:&quot;&quot;, // 角色id
    &quot;tenant&quot;:&quot;&quot;, // 租户id
    &quot;code&quot;:&quot;&quot;, // 角色代码
    &quot;realm&quot;:&quot;&quot;, // 角色领域，global:应用内全局角色；app：app端角色；admin：管理端角色；web: web前端角色；
    &quot;realm_id&quot;:&quot;&quot;, // 领域id，选填。
    &quot;name&quot;:&quot;&quot;, // 角色名称
    &quot;status&quot;:0, // 状态，0 启用，1 禁用
    &quot;type&quot;:0, // 类型：0 正常角色，1 临时角色，2 默认角色
    &quot;valid&quot;:1, // 2：未生效，1：生效
    &quot;valid_time&quot;:&quot;&quot;, // 生效时间
    &quot;invalid_time&quot;:&quot;&quot;, // 失效时间
    &quot;remark&quot;:&quot;管理员&quot;， // 角色备注
    &quot;permissions&quot;: // 分配的权限列表
        [
            PERMISSION_INFO
        ]
}
</code></pre><h3 id="资源-RESOURCE-INFO"><a href="#资源-RESOURCE-INFO" class="headerlink" title="资源 RESOURCE_INFO"></a>资源 RESOURCE_INFO</h3><pre><code>{
    &quot;id&quot;:&quot;&quot;, // 资源id
    &quot;client&quot;:&quot;&quot;, // 客户端类型，取值：app，web，admin
    &quot;code&quot;:&quot;&quot;, // 资源标识符，客户端控制用，全局唯一
    &quot;tag&quot;:&quot;&quot;, // 资源标签
    &quot;remark&quot;:&quot;&quot; // 资源名称，管理后台显示用
}
</code></pre><h3 id="权限-PERMISSION-INFO"><a href="#权限-PERMISSION-INFO" class="headerlink" title="权限 PERMISSION_INFO"></a>权限 PERMISSION_INFO</h3><pre><code>{
    &quot;id&quot;:&quot;&quot;, // 权限id
    &quot;name&quot;:&quot;&quot;, // 权限名称
    &quot;code&quot;:&quot;&quot;, // 权限代码
    &quot;status&quot;:0, // 状态，0 启用，1 禁用
    &quot;remark&quot;:&quot;&quot;, // 权限备注
    &quot;actions&quot;:[ // 权限对应的ACTION列表
        ACTION_INFO,
        ACTION_INFO,
        ...
    ],
    &quot;resources&quot;:[ // 权限对应的资源列表
        RESOURCE_INFO,
        RESOURCE_INFO,
        ...
    ]
}
</code></pre><h3 id="操作-ACTION-INFO"><a href="#操作-ACTION-INFO" class="headerlink" title="操作 ACTION_INFO"></a>操作 ACTION_INFO</h3><pre><code>{
    &quot;id&quot;:&quot;&quot;, // 操作id
    &quot;code&quot;:&quot;&quot;, // 全局唯一:包名.类名.方法
    &quot;biz_type&quot;:&quot;&quot;, // 二级服务需要填写此项
    &quot;uri&quot;:&quot;&quot;, // Restful api，管理后台显示用
    &quot;remark&quot;:&quot;&quot; // api名称，管理后台显示用
}
</code></pre><h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><h3 id="服务端权限校验流程"><a href="#服务端权限校验流程" class="headerlink" title="服务端权限校验流程"></a>服务端权限校验流程</h3><ol>
<li>当前请求接口有@RequirePermission注解，进入鉴权流程。没有@RequirePermission注解，返回鉴权成功</li>
<li>【当前请求接口的@RequirePermission内的权限列表】与【用户的拥有的权限列表】有交集，返回鉴权成功。无交集返回鉴权失败。</li>
<li>RBAC服务器故障，导致角色数据无法获取时，返回鉴权失败，同时启动RBAC Server存活检测线程，存活检查按递增间隔进行检测。发现RBAC Server正常后，重新加载角色数据。</li>
</ol>
<h3 id="客户端权限校验流程"><a href="#客户端权限校验流程" class="headerlink" title="客户端权限校验流程"></a>客户端权限校验流程</h3><ol>
<li>每个组件将自己的所有UI元素中涉及权限控制的资源做成【权限资源列表】，这些资源默认不可见。</li>
<li>从RBAC获取当前登录用户的可见资源列表。</li>
<li>当用户进入某个page时，获取【用户可见资源列表】与【权限资源列表】的交集，将交集的资源设置为可见。</li>
<li>如果RBAC服务端无法连接，则【用户可见资源列表】为空，这些受控资源不可见。</li>
</ol>
<h3 id="缓存更新流程"><a href="#缓存更新流程" class="headerlink" title="缓存更新流程"></a>缓存更新流程</h3><ol>
<li>服务端的角色缓存数据通过MQ订阅通知实现实时更新。</li>
<li>客户端如果使用IM组件时，通过IM事件消息触发更新。如果未使用IM组件，采用定时到服务端检查版本变更的策略，如果数据有更新再去RBAC服务端拉取。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RBAC，即大家很熟悉的“基于角色的访问控制”。理论什么的这里就不讲了，重点介绍下一种基于RBAC的实践。&lt;/p&gt;
&lt;h2 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h2&gt;&lt;ul&gt;
    
    </summary>
    
      <category term="UAA" scheme="http://webfuse.cn/categories/UAA/"/>
    
    
      <category term="实战" scheme="http://webfuse.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="RBAC" scheme="http://webfuse.cn/tags/RBAC/"/>
    
  </entry>
  
  <entry>
    <title>多租户设计</title>
    <link href="http://webfuse.cn/2018/02/15/%E5%A4%9A%E7%A7%9F%E6%88%B7%E8%AE%BE%E8%AE%A1/"/>
    <id>http://webfuse.cn/2018/02/15/多租户设计/</id>
    <published>2018-02-15T01:55:53.000Z</published>
    <updated>2018-07-28T03:19:46.931Z</updated>
    
    <content type="html"><![CDATA[<p>多租户（Multi Tenancy/Tenant）是一种软件架构，其定义是：在一台服务器上运行单个应用实例，它为多个租户提供服务。</p>
<p>多个租户在数据上既有共享又有隔离，常有的存储方式有以下三种：</p>
<p>方案一：独立数据库<br>方案二：共享数据库，隔离数据架构<br>方案三：共享数据库，共享数据架构</p>
<h2 id="独立数据库"><a href="#独立数据库" class="headerlink" title="独立数据库"></a>独立数据库</h2><p>独立数据库即一个租户一个数据库，这种方案的用户数据隔离级别最高，安全性最好，但成本较高。</p>
<p>这种模式下，我们可以为不同的租户提供独立的数据库，针对不同用户的独特需求扩展方便，数据备份以及修复比较简单。但是这种方案增多了数据库的数量，维护成本和购置成本高。</p>
<h2 id="共享数据库，隔离数据架构"><a href="#共享数据库，隔离数据架构" class="headerlink" title="共享数据库，隔离数据架构"></a>共享数据库，隔离数据架构</h2><p>共享数据库，隔离数据架构即多个或所有租户共享Database，但是每个租户一个Schema。</p>
<p>该模式为安全性要求较高的租户提供了一定程度的逻辑数据隔离，并不是完全隔离；每个数据库可支持更多的租户数量。 </p>
<p>但是该模式下，如果数据库出现故障，数据恢复比较困难，因为数据库的恢复会牵扯到其他租户的数据；如果需要跨租户统计数据，存在一定困难。</p>
<h2 id="共享数据库，共享数据架构"><a href="#共享数据库，共享数据架构" class="headerlink" title="共享数据库，共享数据架构"></a>共享数据库，共享数据架构</h2><p>第三种方案，即租户共享同一个Database、同一个Schema，但在表中增加TenantID多租户的数据字段。这是共享程度最高、隔离级别最低的模式。 </p>
<p>这种方案的维护和购置成本最低，允许每个数据库支持的租户数量最多。 </p>
<p>但是这种隔离级别最低，安全性最低，需要在设计开发时加大对安全的开发量；同时数据备份和恢复最困难，需要逐表逐条备份和还原。 </p>
<p>如果希望以最少的服务器为最多的租户提供服务，并且租户接受牺牲隔离级别换取降低成本，这种方案最适合。</p>
<h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p>我们要如何选择这三种模式呢？衡量三种模式主要考虑的因素是隔离还是共享，还有成本。</p>
<p>考虑到成本角度因素：隔离性越好，设计和实现的难度和成本越高，初始成本越高。共享性越好，同一运营成本下支持的用户越多，运营成本越低。</p>
<p>安全因素：要考虑业务和客户的安全方面的要求。安全性要求越高，越要倾向于隔离。</p>
<p>从租户数量上考虑：租户越多，应该越倾向于共享；如果每个租户存储的数据越多，应该越倾向于隔离；每个租户同时访问系统的用户数量越多，应该越倾向于隔离；如果针对每个用户都要提供一些附加服务，就应该越倾向于隔离。</p>
<p>信息监管因素：要考虑政府，机关，企业，公司的安全和信息监管相关的一些政策和规定。</p>
<p>技术储备：共享性越高，对技术的要求越高。</p>
<hr>
<p>参考：</p>
<p><a href="http://www.cnblogs.com/junneyang/p/5212516.html" target="_blank" rel="external">【架构】如何设计支持多租户的数据库？</a></p>
<p><a href="http://blog.csdn.net/yown/article/details/51288549" target="_blank" rel="external">SaaS多租户数据隔离的三种方案</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-dataMultitenant/index.html" target="_blank" rel="external">数据层的多租户浅谈</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多租户（Multi Tenancy/Tenant）是一种软件架构，其定义是：在一台服务器上运行单个应用实例，它为多个租户提供服务。&lt;/p&gt;
&lt;p&gt;多个租户在数据上既有共享又有隔离，常有的存储方式有以下三种：&lt;/p&gt;
&lt;p&gt;方案一：独立数据库&lt;br&gt;方案二：共享数据库，隔离数
    
    </summary>
    
      <category term="UAA" scheme="http://webfuse.cn/categories/UAA/"/>
    
    
      <category term="实战" scheme="http://webfuse.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="多租户" scheme="http://webfuse.cn/tags/%E5%A4%9A%E7%A7%9F%E6%88%B7/"/>
    
  </entry>
  
  <entry>
    <title>多种用户登录模式设计</title>
    <link href="http://webfuse.cn/2018/02/14/%E5%A4%9A%E7%A7%8D%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://webfuse.cn/2018/02/14/多种用户登录模式设计/</id>
    <published>2018-02-14T00:59:06.000Z</published>
    <updated>2018-07-28T03:19:46.930Z</updated>
    
    <content type="html"><![CDATA[<p>在做Web开发的时候，用户登录时最基本的功能。通常情况下，我们直接使用“用户名+密码”的模式，直接在users表中建立用户名密码等字段来完成工作。但是，如果我们的要求是邮箱、手机号和接入第三方的登录都要支持呢？很明显，在这种情况下，基本的用户名密码登录是完成不了我们的要求的。</p>
<p>在这种情况下，我们可以采用“拆表”的方法。这里所谓的拆表就是将一个用户表拆分成为几个表：user_info,user_auth,user_extra等表。user_info表中保存用户的基本信息，如user_id,username,nickname等；user_auth表用来保存用户的认证信息，如user_id,identity_type,identifier和certificate等；user_extra表是用户信息的扩展表，用户的一些扩展信息可以保存在该表中。</p>
<p>表结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 用户信息</span></div><div class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> user_info;</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> user_info (</div><div class="line">  <span class="keyword">id</span> <span class="built_in">VARCHAR</span>(<span class="number">36</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> , <span class="comment">--ID</span></div><div class="line">  username <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  <span class="comment">--用户名</span></div><div class="line">  nickname <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="literal">NULL</span>,  <span class="comment">--昵称</span></div><div class="line">  user_type <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,  <span class="comment">--1管理员用户 2普通用户  3虚拟用户</span></div><div class="line">  avatar <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="literal">NULL</span>, <span class="comment">--头像</span></div><div class="line">  register_source <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="comment">--注册来源：USER_NAME/PHONE/EMAIL/QQ/WECHAT/SINA_WEIBO/DOUBAN/GOOGLE/GITHUB/LINKEDIN/TWITTER/FACEBOOK</span></div><div class="line">  account_non_expired TINYINT <span class="literal">NULL</span>, <span class="comment">--用户是否过期</span></div><div class="line">  account_non_locked TINYINT <span class="literal">NULL</span>,  <span class="comment">--用户是否被锁</span></div><div class="line">  credentials_non_expired TINYINT <span class="literal">NULL</span>, <span class="comment">--证书是否存在</span></div><div class="line">  create_time DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>(),</div><div class="line">  update_time DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>(),</div><div class="line">  <span class="keyword">status</span> <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="comment">--状态，ENABLED（启用）,DISABLE（禁用）</span></div><div class="line">  enabled TINYINT <span class="keyword">DEFAULT</span> <span class="literal">TRUE</span></div><div class="line">);</div><div class="line"><span class="keyword">CREATE</span> PRIMARY <span class="keyword">KEY</span> <span class="keyword">ON</span> user_info (<span class="keyword">id</span>);</div><div class="line"></div><div class="line"><span class="comment">--用户扩展</span></div><div class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> user_extra;</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> user_extra (</div><div class="line">  <span class="keyword">id</span> <span class="built_in">BIGINT</span> AUTO_INCREMENT ,</div><div class="line">  user_id <span class="built_in">VARCHAR</span>(<span class="number">36</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></div><div class="line">);</div><div class="line"><span class="keyword">CREATE</span> PRIMARY <span class="keyword">KEY</span> <span class="keyword">ON</span> user_extra (user_id);</div><div class="line"></div><div class="line"><span class="comment">--用户认证</span></div><div class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> user_auth;</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> user_auth (</div><div class="line">  <span class="keyword">id</span> <span class="built_in">BIGINT</span> AUTO_INCREMENT ,</div><div class="line">  user_id <span class="built_in">VARCHAR</span>(<span class="number">36</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  identity_type <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="comment">--授权来源：USER_NAME/PHONE/EMAIL/QQ/WECHAT/SINA_WEIBO/DOUBAN/GOOGLE/GITHUB/LINKEDIN/TWITTER/FACEBOOK</span></div><div class="line">  identifier <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  <span class="comment">--手机号/邮箱/用户名或第三方应用的唯一标识</span></div><div class="line">  certificate <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="comment">--密码凭证(站内的保存密码，站外的不保存或保存token)</span></div><div class="line">  create_time DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>(),</div><div class="line">  update_time DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>(),</div><div class="line">  <span class="keyword">status</span> <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="comment">--状态，ENABLED（启用）,DISABLE（禁用）</span></div><div class="line">);</div></pre></td></tr></table></figure>
<p>以上，如果我们需要为用户添加一种认证方式，可以在user_auth表中对应添加一条记录。比如，我们需要对接微博认证，那么就直接在user_auth表中添加一条identity_type=SINA_WEIBO的数据记录。我们在登录的时候，就可以直接使用user_auth表的identity_type,identifier和certificate进行认证，从而获得到user_id，然后可以拿user_id到user_info表和user_extra表中获得更多的用户数据。</p>
<p>当然，这种方式也是有缺点的。最主要的缺点就是密码修改，当我们进行修改密码的时候，我们必须对手机号、邮箱以及用户名的所有的密码进行修改。还有一个缺点就是在登录时候要在程序中进行正则匹配，确定是哪种认证方式，那么匹配的顺序就很关键了。</p>
<p>这个也只是一种参考的实现思路，具体的情况具体分析，我们可以根据实际情况进行必要的调整和修改。</p>
<hr>
<p>参考：</p>
<p><a href="http://gglinux.com/2017/03/31/user/" target="_blank" rel="external">用户系统设计与实现</a></p>
<p><a href="http://www.cnblogs.com/nuanxin/p/6215237.html" target="_blank" rel="external">浅谈数据库用户表结构设计，第三方登录</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做Web开发的时候，用户登录时最基本的功能。通常情况下，我们直接使用“用户名+密码”的模式，直接在users表中建立用户名密码等字段来完成工作。但是，如果我们的要求是邮箱、手机号和接入第三方的登录都要支持呢？很明显，在这种情况下，基本的用户名密码登录是完成不了我们的要求的
    
    </summary>
    
      <category term="UAA" scheme="http://webfuse.cn/categories/UAA/"/>
    
    
      <category term="实战" scheme="http://webfuse.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="用户登录" scheme="http://webfuse.cn/tags/%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>《写给大忙人看的JavaSE8》读书笔记</title>
    <link href="http://webfuse.cn/2018/02/08/%E3%80%8A%E5%86%99%E7%BB%99%E5%A4%A7%E5%BF%99%E4%BA%BA%E7%9C%8B%E7%9A%84JavaSE8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://webfuse.cn/2018/02/08/《写给大忙人看的JavaSE8》读书笔记/</id>
    <published>2018-02-08T15:08:32.000Z</published>
    <updated>2018-07-28T03:19:46.917Z</updated>
    
    <content type="html"><![CDATA[<p>重新看了一遍《写给大忙人看的Java SE 8》，简单地做了一下笔记。该书还有很多内容没有细细品味，可以在用到的时候时不时地再翻一番。</p>
<pre><code>import java.io.IOException;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.time.temporal.TemporalAdjuster;
import java.time.temporal.TemporalAdjusters;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.LongAdder;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Java8Demo {

    /**
    * 带有参数变量的表达式都被称为lambda表达式
    * lambda表达式：基本型为 (形参列表)-&gt;{方法体}
    * 方法引用： ::操作符将方法名和对象或类的名字分割开来
    */
    public void aboutLambda() {
        Comparator&lt;String&gt; comp = (str1, str2) -&gt; 0;

        new Thread(() -&gt; {
            for (int i = 0; i &lt; 100; i++)
                System.out.println(&quot;Lambda Expression&quot;);
        }).start();

        //函数式接口：对于只包含一个抽象方法的接口，你可以通过lambda表达式来创建该接口的对象。
        Arrays.sort(new String[]{&quot;a&quot;, &quot;b&quot;}, comp);

        //方法引用等同于提供方法参数的lambda表达式
        Arrays.asList(&quot;&quot;, &quot;&quot;).stream().forEach(System.out::print);//情况1：对象::实例方法
        Arrays.asList(1, 2).stream().map(Math::abs).collect(Collectors.toList());//情况2：类::静态方法
        Arrays.sort(new String[]{&quot;&quot;, &quot;&quot;}, Comparator.comparingInt(String::length)); //情况3：类::实例方法。第一个参数会成为执行方法的对象.String::length 等于 (x)-&gt;x.length()
        String[] arr = Arrays.asList(&quot;&quot;, &quot;&quot;).stream().toArray(String[]::new);   //情况4：类::new

        //所有的lambda表达式都是延迟执行的
    }


    public void aboutStreamAPI() {
        List&lt;String&gt; words = new ArrayList&lt;&gt;();
        long count = words.parallelStream().filter(w -&gt; w.length() &gt; 12).count();

        //Stream遵循“做什么，而不是怎么去做”的原则。
        //在使用Stream时候，你会通过三个阶段来建立一个操作流水线：
        //1-创建一个Stream
        //2-在一个或多个步骤中，指定将初始Stream转换为另一个Stream的中间操作
        //3-使用一个终止操作来产生一个结果。该操作会强制它之前的延迟操作立即执行。在这之后，该Stream操作就不会再被使用了。

        Stream&lt;String&gt; wordStream = Stream.of(new String[]{});
        Stream&lt;String&gt; song = Stream.of(&quot;&quot;, &quot;&quot;, &quot;&quot;);

        Stream&lt;String&gt; echos = Stream.generate(() -&gt; &quot;Echo&quot;); //创建一个含有常亮值的Stream
        Stream&lt;Double&gt; randoms = Stream.generate(Math::random); //创建一个含有随机数的Stream
        //iterate方法接受一个“种子”的值和一个函数作为参数
        Stream&lt;BigInteger&gt; integers = Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.ONE));


        //流转换是指从一个流中读取数据，并将转换后的数据写入到另一个流中。
        //filter方法的参数是一个Predicate&lt;T&gt;对象——即一个从T到boolean的函数。
        //我们使用map方法对流中的值进行某种形式的转换，它会对每个元素应用一个函数，并将返回的值收集到一个新的流中。

        //distinct方法会根据原始流中的元素返回一个具有相同顺序、抑制了重复元素的新流。

        //聚合方法：如果你希望对元素求和，或者以其他方式将流中的元素组合为一个值
        //    - count方法：返回流中元素的总数
        //    - max方法：返回流中最大值
        //    - min方法：返回流中最小值
        //    - reduce方法： 提供聚合操作

        //Optional&lt;T&gt;对象或者是对一个T类型对象的封装，或者表示不是任何对象。
        // if(optionalValue.ifPresent()) optionalValue.get().someMethod();
        // optionalValue.ifPresent(v-&gt;results::add);
        // Optional&lt;Boolean&gt; added = optionalValue.map(results::add);   //返回一个值
        // optionalValue.orElse(&quot;&quot;);
        // optionalValue.orElseGet(()-&gt;System.out.print(&quot;....&quot;));
        // optionalValue.orElseThrow(NoSuchElementException:new);
        // 可以使用Optional.of(result)或者Optional.empty()来创建一个Optional对象
        // ofNullable方法中，如果obj不为null,那么Optional.ofNullable(obj)会返回Optional.of(obj),否则会返回Optional.empty()。
        //使用flatMap来组合可选函数。Optional&lt;U&gt; u =  s.f().flatMap(T::g);

        //以下3个是等效的
        HashSet&lt;String&gt; res = wordStream.collect(HashSet::new, HashSet::add, HashSet::addAll);
        List&lt;String&gt; res1 = wordStream.collect(Collectors.toList());
        Set&lt;String&gt; res2 = wordStream.collect(Collectors.toSet());

        //将字符串连接起来
        String str = wordStream.collect(Collectors.joining());

        //将字符串连接起来，中间以,隔开
        String str1 = wordStream.collect(Collectors.joining(&quot;, &quot;));

        //使用(Int|Double|Long)SummaryStatistics来获得一个流的总和、平均值、最大值或最小值
        IntSummaryStatistics summary = wordStream.collect(Collectors.summarizingInt(String::length));
        double averageWordLength = summary.getAverage();
        double maxWordLength = summary.getMax();

        //将一个Stream对象中的元素收集到一个map中
        //Map&lt;Integer,String&gt; idToName = peopleStream.collect(Collectors.toMap(Person::getId,Person::getName));

        //上面的转换成Map中，如果存在相同的键异常，我们可以重写方法搞定。
        Stream&lt;Locale&gt; locales = Stream.of(Locale.getAvailableLocales());
        Map&lt;String, String&gt; languageNames = locales.collect(Collectors.toMap(
                l -&gt; l.getDisplayLanguage(),
                l -&gt; l.getDisplayLanguage(l),
                (existingValue, newValue) -&gt; existingValue
        ));


        //groupingBy方法，对具有相同特性的值进行分组
        //当分类函数式一个predicate函数（即返回一个布尔值的函数）时，流元素会被分为两组列表：一组是函数会返回true的元素，另一组返回false的元素。
        //在这种情况下，使用partitioningBy会比groupingBy更有效率。

    }

    public void aboutTime() {

        Instant start = Instant.now();
        Instant end = Instant.now();
        Duration timeElapsed = Duration.between(start, end);
        timeElapsed.toMillis();
        timeElapsed.toDays();
        timeElapsed.plusDays(1).getSeconds();
        start.plusMillis(1);

        // 以下是来自廖雪峰的博客
        // Java 8新增了LocalDate和LocalTime接口，为什么要搞一套全新的处理日期和时间的API？因为旧的java.util.Date实在是太难用了。
        // java.util.Date月份从0开始，一月是0，十二月是11，变态吧！java.time.LocalDate月份和星期都改成了enum，就不可能再用错了。
        // java.util.Date和SimpleDateFormatter都不是线程安全的，而LocalDate和LocalTime和最基本的String一样，是不变类型，不但线程安全，而且不能修改。
        // java.util.Date是一个“万能接口”，它包含日期、时间，还有毫秒数，如果你只想用java.util.Date存储日期，或者只存储时间，那么，只有你知道哪些部分的数据是有用的，哪些部分的数据是不能用的。在新的Java 8中，日期和时间被明确划分为LocalDate和LocalTime，LocalDate无法包含时间，LocalTime无法包含日期。当然，LocalDateTime才能同时包含日期和时间。
        // 新接口更好用的原因是考虑到了日期时间的操作，经常发生往前推或往后推几天的情况。用java.util.Date配合Calendar要写好多代码，而且一般的开发人员还不一定能写对。

        // 取当前日期：
        LocalDate today = LocalDate.now(); // -&gt; 2014-12-24
        // 根据年月日取日期，12月就是12：
        LocalDate crischristmas = LocalDate.of(2014, 12, 25); // -&gt; 2014-12-25
        // 根据字符串取：
        LocalDate endOfFeb = LocalDate.parse(&quot;2014-02-28&quot;); // 严格按照ISO yyyy-MM-dd验证，02写成2都不行，当然也有一个重载方法允许自己定义格式
        LocalDate.parse(&quot;2014-02-29&quot;); // 无效日期无法通过：DateTimeParseException: Invalid date

        // LocalTime只包含时间，以前用java.util.Date怎么才能只表示时间呢？答案是，假装忽略日期。
        // LocalTime包含毫秒：
        LocalTime now = LocalTime.now(); // 11:09:09.240

        //你可能想清除毫秒数：
        LocalTime now1 = LocalTime.now().withNano(0); // 11:09:09

        //构造时间也很简单：
        LocalTime zero = LocalTime.of(0, 0, 0); // 00:00:00
        LocalTime mid = LocalTime.parse(&quot;12:00:00&quot;); // 12:00:00

        //日期校正器
        //TemporalAdjusters类提供了很多静态方法来进行常用的校正。你可以将一个校正放的结果传递给with方法。
        LocalDate firstTuesday = LocalDate.of(2018, 2, 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.THURSDAY)); //计算2月的第一个星期二

        //实现自己的校验器
        TemporalAdjuster NEXT_WORKDAY = TemporalAdjusters.ofDateAdjuster(w -&gt; {
            LocalDate result = w;
            do {
                result = result.plusDays(1);
            } while (result.getDayOfWeek().getValue() &gt;= 6);
            return result;
        });
        LocalDate backToWork = LocalDate.now().with(NEXT_WORKDAY);

        //格式化与解析
        // String formatted =  DateTimeFormatter.ISO_DATE_TIME.format();
    }


    public void aboutConcurrency() {
        //原子性 lambda
        // ConcurrentHashMap
        ConcurrentHashMap&lt;String, LongAdder&gt; map = new ConcurrentHashMap();
        map.putIfAbsent(&quot;&quot;, new LongAdder());
        map.get(&quot;&quot;).increment();

        //批量数据操作有三类：
        //1)search会对每个键和（或）值应用一个函数，直到函数返回一个非null的结果。然后search会终止并返回该函数的结果。
        //2)reduce会通过提供的累积函数，将所有的键和（或）值组合起来。
        //3)forEach会对所有的键和（或）值应用一个函数。

        //在使用这几种操作时，你需要指定一个并行阈值。如果映射包含的元素数量超过了这个阈值，批量操作就以并行方式执行。
        //如果你希望批量数据操作在一个线程中运行，请使用Long.MAX_VALUE作为阈值。
        //如果你希望批量数据操作尽可能使用更多的线程，则应该使用1作为阈值。

        Set&lt;String&gt; words = map.keySet();

        //并行数组操作
        //静态方法Arrays.parallelSort可以对原始类型数组或者对象数组进行排序。
        try {
            String contents = new String(Files.readAllBytes(Paths.get(&quot;&quot;)), StandardCharsets.UTF_8);
            String[] words1 = contents.split(&quot;&quot;);
            Arrays.parallelSort(words1);
        } catch (IOException e) {
            e.printStackTrace();
        }

        //可完成的Future
        //Future&lt;T&gt;接口用来表示一个在将来某个时间点可用的、类型为T的值。
    }

    public void aboutOthers() {

        String joined = String.join(&quot;/&quot;, &quot;usr&quot;, &quot;local&quot;, &quot;bin&quot;);
        String ids = String.join(&quot;, &quot;, ZoneId.getAvailableZoneIds());

        Objects.isNull(&quot;&quot;);
        Objects.nonNull(&quot;&quot;);
    }

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新看了一遍《写给大忙人看的Java SE 8》，简单地做了一下笔记。该书还有很多内容没有细细品味，可以在用到的时候时不时地再翻一番。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.io.IOException;
import java.math.BigIntege
    
    </summary>
    
      <category term="读书笔记" scheme="http://webfuse.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://webfuse.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://webfuse.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Ehcache缓存持久化</title>
    <link href="http://webfuse.cn/2017/12/22/Ehcache%E7%BC%93%E5%AD%98%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://webfuse.cn/2017/12/22/Ehcache缓存持久化/</id>
    <published>2017-12-22T01:25:24.000Z</published>
    <updated>2018-07-28T03:19:46.904Z</updated>
    
    <content type="html"><![CDATA[<p>因为在项目中需要将Ehcache的缓存数据写入磁盘，搜索一些怎么样持久化Ehcache缓存的资料，根据获得的资料在开发过程中遇到蛮多的坑，逐一记录下来。</p>
<h2 id="根据官网上的配置踩过的坑"><a href="#根据官网上的配置踩过的坑" class="headerlink" title="根据官网上的配置踩过的坑"></a>根据官网上的配置踩过的坑</h2><p>在Ehcache的官网上，有关于怎么配置持久化的说明。详情见： <a href="http://www.ehcache.org/generated/2.10.4/html/ehc-all/#page/Ehcache_Documentation_Set%2Fto-persist_configuring_persistance_and_restart.html%23" target="_blank" rel="external">Configuring Restartability and Persistence</a></p>
<p>然后，我按照常规的逻辑添加了一下的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"indexCache"</span></span></div><div class="line">       <span class="attr">eternal</span>=<span class="string">"true"</span></div><div class="line">       <span class="attr">maxElementsInMemory</span>=<span class="string">"1"</span></div><div class="line">       <span class="attr">overflowToDisk</span>=<span class="string">"true"</span></div><div class="line">       <span class="attr">diskPersistent</span>=<span class="string">"true"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">persistence</span> <span class="attr">strategy</span>=<span class="string">"localRestartable"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后，报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Caused by: org.xml.sax.SAXException: null:17: Could not finish element &lt;persistence&gt;. Message was: net.sf.ehcache.config.InvalidConfigurationException: Cannot use both &lt;persistence ...&gt; and diskPersistent in a single cache configuration.</div></pre></td></tr></table></figure>
<p>说明diskPersistent和persistence不能共存。修改配置后：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"indexCache"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">persistence</span> <span class="attr">strategy</span>=<span class="string">"localRestartable"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></div></pre></td></tr></table></figure>
<p>启动，报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Caused by: net.sf.ehcache.config.InvalidConfigurationException: There is one error in your configuration: </div><div class="line">	* Cache &apos;indexCache&apos; error: If your CacheManager has no maxBytesLocalHeap set, you need to either set maxEntriesLocalHeap or maxBytesLocalHeap at the Cache level</div></pre></td></tr></table></figure>
<p>添加 maxEntriesLocalHeap 后如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"indexCache"</span> <span class="attr">maxEntriesLocalHeap</span>=<span class="string">"1000"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">persistence</span> <span class="attr">strategy</span>=<span class="string">"localRestartable"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></div></pre></td></tr></table></figure>
<p>还是报错:You must use an enterprise version of Ehcache to successfully enable enterprise persistence.</p>
<p>原来需要用到BigMemory，但是BigMemory又是收费的。至此，第一次尝试失败。</p>
<h2 id="根据网上资料踩过的坑"><a href="#根据网上资料踩过的坑" class="headerlink" title="根据网上资料踩过的坑"></a>根据网上资料踩过的坑</h2><p>资料显示：我们要在每次使用cache.put()后再调用cache.flush()，这样就能够将索引写入到磁盘。同时在配置中开启eternal（永久有效），overflowToDisk（磁盘缓存）， diskPersistent（持久化到磁盘）和<a href="http://blog.csdn.net/xiajun07061225/article/details/40211391" target="_blank" rel="external">预热机制</a>。</p>
<p>然后还要在web.xml中加入ShutdownListener的监听，这样可以保证在正常关闭的时候缓存数据成功写入磁盘。</p>
<p>所以有了以下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"indexCache"</span> <span class="attr">maxElementsInMemory</span>=<span class="string">"1"</span> <span class="attr">eternal</span>=<span class="string">"true"</span> <span class="attr">overflowToDisk</span>=<span class="string">"true"</span></span></div><div class="line">       <span class="attr">diskPersistent</span>=<span class="string">"true"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">bootstrapCacheLoaderFactory</span> <span class="attr">class</span>=<span class="string">"net.sf.ehcache.distribution.RMIBootstrapCacheLoaderFactory"</span></span></div><div class="line">                                 <span class="attr">properties</span>=<span class="string">"bootstrapAsynchronously=true"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> ServletListenerRegistrationBean&lt;ShutdownListener&gt; <span class="title">testListenerRegistration</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServletListenerRegistrationBean&lt;&gt;(<span class="keyword">new</span> ShutdownListener());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>启动试验，发现只生成.data文件并没有生成.index文件。</p>
<h2 id="跳出坑，解决问题"><a href="#跳出坑，解决问题" class="headerlink" title="跳出坑，解决问题"></a>跳出坑，解决问题</h2><p>跟踪调试代码，发现cache.flush()调用的是CacheStore中的flush。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (authoritativeTier <span class="keyword">instanceof</span> DiskStore &amp;&amp; cacheConfiguration != <span class="keyword">null</span> &amp;&amp; cacheConfiguration.isClearOnFlush()) &#123;</div><div class="line">        <span class="keyword">final</span> Lock lock = daLock.writeLock();</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            cachingTier.clear();</div><div class="line">            ((DiskStore)authoritativeTier).clearFaultedBit();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        authoritativeTier.flush();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序总是进入if条件中，并没有调用到<code>authoritativeTier.flush()</code>方法。</p>
<p>修改配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"indexCache"</span> <span class="attr">maxElementsInMemory</span>=<span class="string">"1"</span> <span class="attr">eternal</span>=<span class="string">"true"</span> <span class="attr">overflowToDisk</span>=<span class="string">"true"</span></span></div><div class="line">       <span class="attr">diskPersistent</span>=<span class="string">"true"</span> <span class="attr">clearOnFlush</span>=<span class="string">"false"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">bootstrapCacheLoaderFactory</span> <span class="attr">class</span>=<span class="string">"net.sf.ehcache.distribution.RMIBootstrapCacheLoaderFactory"</span></span></div><div class="line">                                 <span class="attr">properties</span>=<span class="string">"bootstrapAsynchronously=true"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></div></pre></td></tr></table></figure>
<p>重新运行，OK。</p>
<p>以上基于spring boot 1.5.4.RELEASE，ehcache的版本为2.10.4</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为在项目中需要将Ehcache的缓存数据写入磁盘，搜索一些怎么样持久化Ehcache缓存的资料，根据获得的资料在开发过程中遇到蛮多的坑，逐一记录下来。&lt;/p&gt;
&lt;h2 id=&quot;根据官网上的配置踩过的坑&quot;&gt;&lt;a href=&quot;#根据官网上的配置踩过的坑&quot; class=&quot;hea
    
    </summary>
    
      <category term="缓存" scheme="http://webfuse.cn/categories/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="实战" scheme="http://webfuse.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="Ehcache" scheme="http://webfuse.cn/tags/Ehcache/"/>
    
  </entry>
  
  <entry>
    <title>在SpringCloud Zuul中使用WebSockets</title>
    <link href="http://webfuse.cn/2017/11/15/%E5%9C%A8SpringCloud%20Zuul%E4%B8%AD%E4%BD%BF%E7%94%A8WebSockets/"/>
    <id>http://webfuse.cn/2017/11/15/在SpringCloud Zuul中使用WebSockets/</id>
    <published>2017-11-15T01:46:38.000Z</published>
    <updated>2018-07-28T03:19:46.929Z</updated>
    
    <content type="html"><![CDATA[<p>近期的项目中需要用到WebSocket，因为使用的是微服务架构，所以又直接使用了Spring Cloud的Zuul。然而，Zuul对WebSocket的支持不是那么友好，具体可以参考：<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/163。" target="_blank" rel="external">https://github.com/spring-cloud/spring-cloud-netflix/issues/163。</a></p>
<p>Spring已经给我们提供了一套<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#websocket" target="_blank" rel="external">WebSockets的解决方案</a>。我们需要用到的有：Sock.js、STOMP、Spring Messaging以及Spring Integration。</p>
<p><strong>Sock.js</strong></p>
<p><a href="https://github.com/sockjs/sockjs-client" target="_blank" rel="external">Sock.js</a>是一个JavaScript代码库，提供WebSocket-like对象、跨浏览器的JavaScript的API。它在浏览器和web服务器之间创建了一个低延迟、全双工、跨域通信通道。在低版本的浏览器不支持WebSocket时，它可以使用其他协议来处理。</p>
<p><strong>STOMP</strong></p>
<p><a href="https://stomp.github.io/" target="_blank" rel="external">STOMP</a>是一种简单的（或流媒体）的消息传递协议。在多种语言、平台和代理之间提供简单和广泛的消息互操作性。</p>
<p><strong>Spring组件</strong></p>
<p>我们在项目中大量使用Spring组件，在这里我们使用到了Spring Messaging和Spring Integration。</p>
<p>Spring Messaging和Spring Integration具体与SockJs、STOMP组合使用可以参考：</p>
<p><a href="https://spring.io/guides/gs/messaging-stomp-websocket/" target="_blank" rel="external">https://spring.io/guides/gs/messaging-stomp-websocket/</a></p>
<p><a href="http://assets.spring.io/wp/WebSocketBlogPost.html" target="_blank" rel="external">http://assets.spring.io/wp/WebSocketBlogPost.html</a></p>
<p><strong>Zuul中的处理</strong></p>
<p>在使用Zuul作为网关的时候，因为我们使用的是Sock.js，所以它可以算得上是支持了。但是为了能够更保险些，需要写一个Filter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        RequestContext context = RequestContext.getCurrentContext();</div><div class="line">        HttpServletRequest request = context.getRequest();</div><div class="line">        String upgradeHeader = request.getHeader(<span class="string">"Upgrade"</span>);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == upgradeHeader) &#123;</div><div class="line">            upgradeHeader = request.getHeader(<span class="string">"upgrade"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != upgradeHeader &amp;&amp; <span class="string">"websocket"</span>.equalsIgnoreCase(upgradeHeader)) &#123;</div><div class="line">            context.addZuulRequestHeader(<span class="string">"connection"</span>, <span class="string">"Upgrade"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Spring WebSockets默认的心跳时间是25s，为了能够不被认为是连接超时，我们需要在Zuul中设置比较长的超时时间。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">hystrix:</span></div><div class="line"><span class="attr">  command:</span></div><div class="line"><span class="attr">    default:</span></div><div class="line"><span class="attr">      execution:</span></div><div class="line"><span class="attr">        isolation:</span></div><div class="line"><span class="attr">          thread:</span></div><div class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">60000</span>  <span class="comment">#设置API网关中路由转发请求的HystrixCommand执行超时时间</span></div><div class="line"></div><div class="line"><span class="attr">ribbon:</span></div><div class="line"><span class="attr">  ConnectTimeout:</span> <span class="number">3000</span> <span class="comment">#设置路由转发请求的时候，创建请求连接的超时时间</span></div><div class="line"><span class="attr">  ReadTimeout:</span> <span class="number">60000</span>  <span class="comment">#用来设置路由转发请求的超时时间</span></div></pre></td></tr></table></figure>
<p>以上，基本上是完成了Zuul与WebSockets之间的代理了。</p>
<hr>

<p>参考：</p>
<p><a href="https://jmnarloch.wordpress.com/2015/11/11/spring-cloud-sock-js-stomp-zuul-no-websockets/" target="_blank" rel="external">https://jmnarloch.wordpress.com/2015/11/11/spring-cloud-sock-js-stomp-zuul-no-websockets/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期的项目中需要用到WebSocket，因为使用的是微服务架构，所以又直接使用了Spring Cloud的Zuul。然而，Zuul对WebSocket的支持不是那么友好，具体可以参考：&lt;a href=&quot;https://github.com/spring-cloud/spri
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://webfuse.cn/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="http://webfuse.cn/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Data MongoDB中的自定义级联</title>
    <link href="http://webfuse.cn/2017/11/10/Spring%20Data%20MongoDB%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%A7%E8%81%94/"/>
    <id>http://webfuse.cn/2017/11/10/Spring Data MongoDB中的自定义级联/</id>
    <published>2017-11-10T10:26:52.000Z</published>
    <updated>2018-07-28T03:19:46.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用Spring Data操作MongoDB中：</p>
<ul>
<li>在保存一个实体的时候，如果被@DBRef标识的类只传入Id，保存后返回的结果并没有全部的引用类内容，只有Id。</li>
<li>保存实体，不能保存引用实体。</li>
</ul>
<p>例如：我们有一个实体<code>Person</code>，有一个实体<code>EmailAddress</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Document</span>(collection = <span class="string">"test_person"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="meta">@DBRef</span></div><div class="line">    <span class="keyword">private</span> EmailAddress emailAddress;</div><div class="line"></div><div class="line">    ... getter setter 方法</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Document</span>(collection = <span class="string">"test_email"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailAddress</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Id</span></div><div class="line">    <span class="keyword">private</span> String id;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String value;</div><div class="line"></div><div class="line">   ... getter setter 方法</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们调用保存方法的时候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">    Person person = <span class="keyword">new</span> Person();</div><div class="line">    person.setName(<span class="string">"test"</span>);</div><div class="line"></div><div class="line">    EmailAddress emailAddress = <span class="keyword">new</span> EmailAddress();</div><div class="line">    emailAddress.setId(<span class="string">"5a05108d4dcc5dece03c9e69"</span>);</div><div class="line"></div><div class="line">    person.setEmailAddress(emailAddress);</div><div class="line"></div><div class="line">    testRepository.save(person);</div><div class="line">    <span class="keyword">return</span> person;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述的代码中，返回的person只有id，没有emailAddress的其他值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">    Person person = <span class="keyword">new</span> Person();</div><div class="line">    person.setName(<span class="string">"test"</span>);</div><div class="line"></div><div class="line">    EmailAddress emailAddress = <span class="keyword">new</span> EmailAddress();</div><div class="line">    emailAddress.setName(<span class="string">"afafa"</span>);</div><div class="line"></div><div class="line">    person.setEmailAddress(emailAddress);</div><div class="line"></div><div class="line">    testRepository.save(person);</div><div class="line">    <span class="keyword">return</span> person;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述的代码中，emailAddress不能被保存。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="生命周期事件"><a href="#生命周期事件" class="headerlink" title="生命周期事件"></a>生命周期事件</h3><p>Spring Data MongoDB中存在一些生命周期事件，如：onBeforeConvert, onBeforeSave, onAfterSave, onAfterLoad and onAfterConvert等。我们可以继承<code>AbstractMappingEventListener</code>，然后重写这些方法，即可以实现。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * MongoDB级联控制</div><div class="line"> * Created by guanzhenxing on 2017/11/9.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CascadeControlMongoEventListener</span> <span class="keyword">extends</span> <span class="title">AbstractMongoEventListener</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> MongoOperations mongoOperations;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAfterSave</span><span class="params">(AfterSaveEvent&lt;Object&gt; event)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onAfterSave(event);</div><div class="line">        Object source = event.getSource();</div><div class="line">        ReflectionUtils.doWithFields(source.getClass(), <span class="keyword">new</span> CascadeAfterSaveCallback(source, mongoOperations));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBeforeConvert</span><span class="params">(BeforeConvertEvent&lt;Object&gt; event)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onBeforeConvert(event);</div><div class="line">        Object source = event.getSource();</div><div class="line">        ReflectionUtils.doWithFields(source.getClass(), <span class="keyword">new</span> CascadeBeforeConvertCallback(source, mongoOperations));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 级联控制的回调</div><div class="line"> * Created by guanzhenxing on 2017/11/10.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CascadeAfterSaveCallback</span> <span class="keyword">implements</span> <span class="title">ReflectionUtils</span>.<span class="title">FieldCallback</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object source;</div><div class="line">    <span class="keyword">private</span> MongoOperations mongoOperations;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CascadeAfterSaveCallback</span><span class="params">(<span class="keyword">final</span> Object source, <span class="keyword">final</span> MongoOperations mongoOperations)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.source = source;</div><div class="line">        <span class="keyword">this</span>.mongoOperations = mongoOperations;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(<span class="keyword">final</span> Field field)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</div><div class="line">        ReflectionUtils.makeAccessible(field);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (field.isAnnotationPresent(DBRef.class)) &#123;</div><div class="line">            <span class="keyword">final</span> Object fieldValue = field.get(source);   <span class="comment">//获得值</span></div><div class="line">            <span class="keyword">if</span> (fieldValue != <span class="keyword">null</span>) &#123;</div><div class="line">                doCascadeLoad(field);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 级联查询</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> field</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCascadeLoad</span><span class="params">(Field field)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</div><div class="line">        Object fieldValue = field.get(source);</div><div class="line">        List&lt;Field&gt; idFields = ReflectionUtil.getAnnotationField(fieldValue, Id.class); <span class="comment">//该方法是为了获得所有的被@Id注解的属性</span></div><div class="line">        <span class="keyword">if</span> (idFields.size() == <span class="number">1</span>) &#123; <span class="comment">//只处理一个Id</span></div><div class="line">            Object idValue = ReflectionUtil.getFieldValue(fieldValue, idFields.get(<span class="number">0</span>).getName());</div><div class="line">            Object value = mongoOperations.findById(idValue, fieldValue.getClass());    <span class="comment">//查询获得值</span></div><div class="line">            ReflectionUtil.setFieldValue(source, field.getName(), value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CascadeBeforeConvertCallback</span> <span class="keyword">implements</span> <span class="title">ReflectionUtils</span>.<span class="title">FieldCallback</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object source;</div><div class="line">    <span class="keyword">private</span> MongoOperations mongoOperations;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CascadeBeforeConvertCallback</span><span class="params">(Object source, MongoOperations mongoOperations)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.source = source;</div><div class="line">        <span class="keyword">this</span>.mongoOperations = mongoOperations;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Field field)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</div><div class="line">        ReflectionUtils.makeAccessible(field);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (field.isAnnotationPresent(DBRef.class)) &#123;</div><div class="line">            <span class="keyword">final</span> Object fieldValue = field.get(source);   <span class="comment">//获得值</span></div><div class="line">            <span class="keyword">if</span> (fieldValue != <span class="keyword">null</span>) &#123;</div><div class="line">                doCascadeSave(field);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 级联保存</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> field</div><div class="line">     * <span class="doctag">@throws</span> IllegalAccessException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCascadeSave</span><span class="params">(Field field)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (field.isAnnotationPresent(CascadeSave.class)) &#123; <span class="comment">//如果有标识@CascadeSave注解</span></div><div class="line">            Object fieldValue = field.get(source);</div><div class="line">            List&lt;Field&gt; idFields = ReflectionUtil.getAnnotationField(fieldValue, Id.class);</div><div class="line">            <span class="keyword">if</span> (idFields.size() == <span class="number">1</span>) &#123;</div><div class="line">                mongoOperations.save(fieldValue);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CascadeSave &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoConfig</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> CascadeControlMongoEventListener <span class="title">userCascadingMongoEventListener</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CascadeControlMongoEventListener();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是核心代码。至此，我们就可以解决上述的问题了。</p>
<p><hr><br>参考：<a href="http://www.baeldung.com/cascading-with-dbref-and-lifecycle-events-in-spring-data-mongodb" target="_blank" rel="external">http://www.baeldung.com/cascading-with-dbref-and-lifecycle-events-in-spring-data-mongodb</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在使用Spring Data操作MongoDB中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在保存一个实体的时候，如果被@DBRef标识的类只传入Id，保
    
    </summary>
    
      <category term="MongoDB" scheme="http://webfuse.cn/categories/MongoDB/"/>
    
    
      <category term="实战" scheme="http://webfuse.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="MongoDB" scheme="http://webfuse.cn/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>将一个JavaBean中的非空属性转到Map中</title>
    <link href="http://webfuse.cn/2017/11/09/%E5%B0%86%E4%B8%80%E4%B8%AAJavaBean%E4%B8%AD%E7%9A%84%E9%9D%9E%E7%A9%BA%E5%B1%9E%E6%80%A7%E8%BD%AC%E5%88%B0Map%E4%B8%AD/"/>
    <id>http://webfuse.cn/2017/11/09/将一个JavaBean中的非空属性转到Map中/</id>
    <published>2017-11-09T08:44:42.000Z</published>
    <updated>2018-07-28T03:19:46.937Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写项目的时候遇到一个这样的一个需要：将JavaBean中非空属性转到一个Map中。stackoverflow出一个还算不错的回答，记录如下：</p>
<p>stackoverflow地址：<a href="https://stackoverflow.com/questions/8524011/java-reflection-how-can-i-get-the-all-getter-methods-of-a-java-class-and-invoke" target="_blank" rel="external">https://stackoverflow.com/questions/8524011/java-reflection-how-can-i-get-the-all-getter-methods-of-a-java-class-and-invoke</a></p>
<p>最佳答案（大概意思的翻译）：</p>
<p>不要用正则表达式，使用<a href="https://docs.oracle.com/javase/6/docs/api/java/beans/Introspector.html" target="_blank" rel="external">Introspector</a>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(PropertyDescriptor propertyDescriptor :</div><div class="line">    Introspector.getBeanInfo(yourClass).getPropertyDescriptors())&#123;</div><div class="line"></div><div class="line">    <span class="comment">// propertyEditor.getReadMethod() exposes the getter</span></div><div class="line">    <span class="comment">// btw, this may be null if you have a write-only property</span></div><div class="line">    System.out.println(propertyDescriptor.getReadMethod());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通常情况下，我们不需要Object.class的属性，所以我们可以使用以下方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> Introspector.getBeanInfo(yourClass, stopClass)</div><div class="line"><span class="comment">// usually with Object.class as 2nd param</span></div><div class="line"><span class="comment">// the first class is inclusive, the second exclusive</span></div></pre></td></tr></table></figure>
<p>我们还可以使用commons/beanutils的一些方法，如：<code>Map&lt;String, String&gt; properties = BeanUtils.describe(yourObject);</code>它会找到并执行所有的getter并将结果存储到Map中，而且BeanUtils.describe()在返回之前将所有的属性值转换为字符串。</p>
<p>以下是一个用Java 8写的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">beanProperties</span><span class="params">(Object bean)</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> Arrays.asList(</div><div class="line">         Introspector.getBeanInfo(bean.getClass(), Object.class)</div><div class="line">                     .getPropertyDescriptors()</div><div class="line">      )</div><div class="line">      .stream()</div><div class="line">      <span class="comment">// filter out properties with setters only</span></div><div class="line">      .filter(pd -&gt; Objects.nonNull(pd.getReadMethod()))</div><div class="line">      .collect(Collectors.toMap(</div><div class="line">        <span class="comment">// bean property name</span></div><div class="line">        PropertyDescriptor::getName,</div><div class="line">        pd -&gt; &#123; <span class="comment">// invoke method to get value</span></div><div class="line">            <span class="keyword">try</span> &#123; </div><div class="line">                <span class="keyword">return</span> pd.getReadMethod().invoke(bean);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                <span class="comment">// replace this with better error handling</span></div><div class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;));</div><div class="line">  &#125; <span class="keyword">catch</span> (IntrospectionException e) &#123;</div><div class="line">    <span class="comment">// and this, too</span></div><div class="line">    <span class="keyword">return</span> Collections.emptyMap();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上方法有一个缺点：Collectors.toMap()对于null的值会报错。所以，有了以下版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">beanProperties</span><span class="params">(Object bean)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Arrays.asList(Introspector.getBeanInfo(bean.getClass(), Object.class)</div><div class="line">                                  .getPropertyDescriptors())</div><div class="line">              .stream()</div><div class="line">              <span class="comment">// filter out properties with setters only</span></div><div class="line">              .filter(pd -&gt; Objects.nonNull(pd.getReadMethod()))</div><div class="line">              .forEach(pd -&gt; &#123; <span class="comment">// invoke method to get value</span></div><div class="line">                  <span class="keyword">try</span> &#123;</div><div class="line">                      Object value = pd.getReadMethod().invoke(bean);</div><div class="line">                      <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">                          map.put(pd.getName(), value);</div><div class="line">                      &#125;</div><div class="line">                  &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                      <span class="comment">// add proper error handling here</span></div><div class="line">                  &#125;</div><div class="line">              &#125;);</div><div class="line">        <span class="keyword">return</span> map;</div><div class="line">    &#125; <span class="keyword">catch</span> (IntrospectionException e) &#123;</div><div class="line">        <span class="comment">// and here, too</span></div><div class="line">        <span class="keyword">return</span> Collections.emptyMap();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Guava版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">guavaBeanProperties</span><span class="params">(Object bean)</span> </span>&#123;</div><div class="line">    Object NULL = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> Maps.transformValues(</div><div class="line">                Arrays.stream(</div><div class="line">                        Introspector.getBeanInfo(bean.getClass(), Object.class)</div><div class="line">                                    .getPropertyDescriptors())</div><div class="line">                      .filter(pd -&gt; Objects.nonNull(pd.getReadMethod()))</div><div class="line">                      .collect(ImmutableMap::&lt;String, Object&gt;builder,</div><div class="line">                               (builder, pd) -&gt; &#123;</div><div class="line">                                   <span class="keyword">try</span> &#123;</div><div class="line">                                       Object result = pd.getReadMethod()</div><div class="line">                                                         .invoke(bean);</div><div class="line">                                       builder.put(pd.getName(),</div><div class="line">                                                   firstNonNull(result, NULL));</div><div class="line">                                   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                                       <span class="keyword">throw</span> propagate(e);</div><div class="line">                                   &#125;</div><div class="line">                               &#125;,</div><div class="line">                               (left, right) -&gt; left.putAll(right.build()))</div><div class="line">                      .build(), v -&gt; v == NULL ? <span class="keyword">null</span> : v);</div><div class="line">    &#125; <span class="keyword">catch</span> (IntrospectionException e) &#123;</div><div class="line">        <span class="keyword">throw</span> propagate(e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，还有一个JavaSlang的版本。基本上很少用这个，就不收集了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写项目的时候遇到一个这样的一个需要：将JavaBean中非空属性转到一个Map中。stackoverflow出一个还算不错的回答，记录如下：&lt;/p&gt;
&lt;p&gt;stackoverflow地址：&lt;a href=&quot;https://stackoverflow.com/quest
    
    </summary>
    
      <category term="Java" scheme="http://webfuse.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://webfuse.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>在使用SpringBoot的时候遇到的一些小坑</title>
    <link href="http://webfuse.cn/2017/10/28/%E5%9C%A8%E4%BD%BF%E7%94%A8SpringBoot%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%9D%91/"/>
    <id>http://webfuse.cn/2017/10/28/在使用SpringBoot的时候遇到的一些小坑/</id>
    <published>2017-10-28T07:39:32.000Z</published>
    <updated>2018-07-28T03:19:46.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入了spring-boot-starter-jdbc但是没有配置数据源"><a href="#引入了spring-boot-starter-jdbc但是没有配置数据源" class="headerlink" title="引入了spring-boot-starter-jdbc但是没有配置数据源"></a>引入了spring-boot-starter-jdbc但是没有配置数据源</h2><p>出现问题原因：在开发过程中把一些公关的东西封装成一个jar包，多个项目共同使用这个jar包（这个jar中包含数据处理的代码）。然而，有些项目没有用到数据处理，没有配置数据源。所以，在启动的时候会报错。</p>
<p>解决方案：引入<code>@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})</code></p>
<h2 id="使用RestTemplate访问restful服务的异常处理"><a href="#使用RestTemplate访问restful服务的异常处理" class="headerlink" title="使用RestTemplate访问restful服务的异常处理"></a>使用RestTemplate访问restful服务的异常处理</h2><p>问题描述：</p>
<p>在使用RestTemplate访问restful接口的时候，如果接口抛出异常，默认情况下捕获的异常不符合自定义的异常规范。</p>
<p>解决：</p>
<p>RestTemplate默认使用的是<code>DefaultResponseErrorHandler</code>处理异常。如果我们需要定制自己的一处处理，可以编写定制化的处理器：</p>
<p>如：</p>
<pre><code>public class CustomResponseErrorHandler implements ResponseErrorHandler {

    private ResponseErrorHandler errorHandler = new DefaultResponseErrorHandler();

    @Override
    public boolean hasError(ClientHttpResponse response) throws IOException {
        return errorHandler.hasError(response);
    }

    @Override
    public void handleError(ClientHttpResponse response) throws IOException {

        String theString = IOUtils.toString(response.getBody());
        Map&lt;String, String&gt; error = (Map&lt;String, String&gt;) JsonMapper.fromJsonString(theString, Map.class);
        String errorCode = error.get(&quot;errorCode&quot;);
        String message = error.get(&quot;message&quot;);

        throw new RemoteCallException(errorCode, message, null);

    }
}
</code></pre><p>然后</p>
<pre><code>RestTemplate restTemplate = new RestTemplate();
restTemplate.setErrorHandler(new CustomResponseErrorHandler());
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引入了spring-boot-starter-jdbc但是没有配置数据源&quot;&gt;&lt;a href=&quot;#引入了spring-boot-starter-jdbc但是没有配置数据源&quot; class=&quot;headerlink&quot; title=&quot;引入了spring-boot-start
    
    </summary>
    
      <category term="开发工具" scheme="http://webfuse.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="实战" scheme="http://webfuse.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="Spring Boot" scheme="http://webfuse.cn/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ Idea取消Could not autowire. No beans of &#39;xxxx&#39; type found的错误提示</title>
    <link href="http://webfuse.cn/2017/10/28/IntelliJ%20Idea%E5%8F%96%E6%B6%88Could%20not%20autowire.%20No%20beans%20of%20&#39;xxxx&#39;%20type%20found%E7%9A%84%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA/"/>
    <id>http://webfuse.cn/2017/10/28/IntelliJ Idea取消Could not autowire. No beans of &#39;xxxx&#39; type found的错误提示/</id>
    <published>2017-10-28T07:17:47.000Z</published>
    <updated>2018-07-28T03:19:46.909Z</updated>
    
    <content type="html"><![CDATA[<p>遇到的问题：</p>
<p>在IntelliJ Idea使用Spring的@Autowired，有的时候遇到“Could not autowire. No beans of ‘xxxx’ type found”的标红提示。但是在程序的编译和运行时候都没有出现这个问题。</p>
<p>解决：</p>
<p>在出现该问题的地方加上<code>@SuppressWarnings(&quot;SpringJavaAutowiringInspection&quot;)</code>注解</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇到的问题：&lt;/p&gt;
&lt;p&gt;在IntelliJ Idea使用Spring的@Autowired，有的时候遇到“Could not autowire. No beans of ‘xxxx’ type found”的标红提示。但是在程序的编译和运行时候都没有出现这个问题。&lt;/p
    
    </summary>
    
      <category term="开发工具" scheme="http://webfuse.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="实战" scheme="http://webfuse.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="Spring" scheme="http://webfuse.cn/tags/Spring/"/>
    
  </entry>
  
</feed>
